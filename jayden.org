#+title: My Emacs Configuration
#+AUTHOR: =Dang Quang Vu=
#+EMAIL: jayden@openedu101.com
#+SUBTITLE: Emacs configuration for work and life
#+property: header-args:emacs-lisp :mkdirp yes :lexical t :exports code
#+property: header-args:emacs-lisp+ :tangle ./init.el
#+property: header-args:emacs-lisp+ :mkdirp yes :noweb no-export

* Package Management
** Repositories
By default, only GNU’s repositories are available to the package managers of Emacs. I also want to use Melpa and org-mode’s repository, so let’s add them! Note that the stock /elpa/ repository is renamed to /gnu/ due to the addition of another Elpa repository, /nongnu/, which will hosts packages that do not conform to the FSF’s copyright assignment. Both the /gnu/ and the /nonfree/ repositories are Elpa repositories now, and they are renamed here in order to avoid any confusion between the two of them. Melpa is a community-maintained repository which contains an absurd amount of Emacs packages.

#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
(setq package-archives '(("melpa"  . "https://melpa.org/packages/")
                         ("gnu"    . "https://elpa.gnu.org/packages/")
                         ("nongnu" . "https://elpa.nongnu.org/nongnu/")))
#+end_src

** Straight
For my package management, I prefer to use ~straight~ ([[https://github.com/raxod502/straight.el][Github]]). This is due to its capacity of integrating nicely with ~use-package~, which also supports ~general~ which I use for my keybindings (see below), but also because with it I can specify where to retrieve packages that are not on MELPA or ELPA but on Github and other online Git repositories too. First, let’s bootstrap straight.
#+begin_src emacs-lisp
(defvar native-comp-deferred-compilation-deny-list ())
(defvar native-comp-jit-compilation-deny-list ())
(defvar comp-deferred-compilation-deny-list ()) ; workaround, otherwise straight shits itself
(customize-set-variable 'native-comp-speed 3)
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

Now, we can refresh our package list in order to be able to install stuff.
#+begin_src emacs-lisp
(package-initialize)
(unless package-archive-contents
  (package-refresh-contents))

#+end_src

From time to time, I fork some packages either because I’m trying to implement something new in said package, or because the package is unmaintained and I want to continue developing it a bit more. Straight provides a nice feature for using forks of a package with its ~:fork~ option. If set to ~t~, then straight will attempt to retrieve the package with the same name but with a different username on the same host. This username is retrieved through the following variable:
#+begin_src emacs-lisp
(setq straight-host-usernames
      '((github . "jayden-dang")
        (gitlab . "jayden-dang")))
#+end_src

The huge advantage of straight is it clones through git the packages it installs. This means development can be done directly on the downloaded package. However, Forge (a Magit extension for interacting with websites such as Github, Gitlab, and such) interacts by default with the forge described by the ~origin~ remote, which isn’t necessarily the one I want Forge to interact with by default. Therefore, all default remotes are named ~straight~ so it won’t collide with my regular development flow.
#+begin_src emacs-lisp
(setq straight-vc-git-default-remote-name "straight")
#+end_src

We finally come to the ~use-package~ installation. This is done like so:
#+begin_src emacs-lisp
(straight-use-package '(use-package :build t))
(setq use-package-always-ensure t)
#+end_src

** Auth
+ This uses ~pass~ for all auth storage. if there are problems remember ~(setq auth-source-debug t)~
#+begin_src emacs-lisp
(auth-source-pass-enable)
(setq epg-gpg-program "gpg2")
#+end_src
+ Let Emacs query the pass phrase instead of an external pinentry dialogue
#+begin_src emacs-lisp
(customize-set-variable 'epg-pinentry-mode 'loopback)
#+end_src
+ Access Folder
#+begin_src emacs-lisp
(setq insert-directory-program "gls" dired-use-ls-dired t)
(setq dired-listing-switches "-al --group-directories-first")

;; Also auto refresh dired, but be quiet about it
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)
#+end_src

** Load-paths
#+begin_src emacs-lisp
;; Add my library path to load-path
(add-to-list 'load-path "~/.emacs.d/lisp/")
(add-to-list 'load-path "~/.emacs.d/lisp/screenshot.el")
(add-to-list 'load-path "~/.emacs.d/lisp/oauth2.el")
(add-to-list 'load-path "~/.emacs.d/lisp/cadence-mode")
(add-to-list 'load-path "~/.emacs.d/lisp/cadence-mode/cadence-mode.el")
(add-to-list 'load-path "~/.emacs.d/lisp/maple-iedit")
(add-to-list 'load-path "~/.emacs.d/lisp/protobuf-mode/")

(require 'cadence-mode)
(require 'oauth2)
(require 'screenshot)
#+end_src

* Basic Configuration
** Early Init
The early init file is the file loaded before anything else in Emacs. This is where I put some options in order to disable as quickly as possible some built-in features of Emacs before they can be even loaded, speeding Emacs up a bit.
#+begin_src emacs-lisp :mkdirp yes :tangle ~/.emacs.d/early-init.el :export code :results silent :lexical t
;; NOTE: Setting `font-lock-multiline' to 'undecided' org-mode to become unusable:
;; Error during redisplay: (jit-lock-function 22138) signaled (args-out-of-range 0 16341)
(setq-default font-lock-multiline nil)

;;; Better defaults
(set-language-environment "UTF-8")
(setq default-input-method nil)

;; better simple ui
(tool-bar-mode -1)
(scroll-bar-mode -1)
(menu-bar-mode -1)
(blink-cursor-mode 0)

(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)

(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(fullscreen . maximized) default-frame-alist)
(push '(ns-use-native-fullscreen . t) default-frame-alist)
(push '(vertical-scroll-bars . nil) default-frame-alist)


(setq visible-bell nil ;; set to non-nil to flash!
      ring-bell-function 'ignore
      large-file-warning-threshold (* 50 1024 1024) ;; change to 50 MiB
      use-short-answers t ;; y or n istead of yes or no
      confirm-kill-emacs 'y-or-n-p ;; confirm before quitting
      inhibit-startup-message t
      delete-by-moving-to-trash t)


(setq frame-inhibit-implied-resize t
      frame-resize-pixelwise t
      frame-title-format nil
      truncate-lines t
      truncate-partial-width-windows t
      package-enable-at-startup nil
      indicate-buffer-boundaries '((bottom . right))
      inhibit-splash-screen t
      inhibit-startup-buffer-menu t
      inhibit-startup-message t
      inhibit-startup-screen t
      inhibit-compacting-font-caches t
      initial-scratch-message nil
      load-prefer-newer noninteractive
      site-run-file nil)

;; (setq debug-on-error t)

(setq auth-sources '("~/.authinfo") ;; Defaults to GPG
      auth-source-do-cache t
      auth-source-cache-expiry 86400 ; All day, defaut is 2h (7200)
      password-cache t
      password-cache-expiry 86400)

;;; Undo
(setq undo-limit        10000000 ;; 1MB (default is 160kB)
      undo-strong-limit 100000000 ;; 100MB (default is 240kB)
      undo-outer-limit  1000000000) ;; 1GB (default is 24MB)

;;; Editing
(setq display-line-numbers-type 'relative
      tab-always-indent nil
      whitespace-action '(cleanup auto-cleanup))

(setq-default fill-column 140
              indent-tabs-mode nil
              display-line-numbers-width 3
              tab-width 2)

;;; Backups
;; Disable backup and lockfiles
(setq create-lockfiles nil
      make-backup-files nil
      version-control t ;; number each backup file
      backup-by-copying t ;; copy instead of renaming current file
      delete-old-versions t ;; clean up after itself
      kept-old-versions 5
      kept-new-versions 5
      tramp-backup-directory-alist backup-directory-alist)

;;; Auto-Saving, sessions...
;; Enable auto-save (use `recover-file' or `recover-session' to recover)
(setq auto-save-default t
      auto-save-include-big-deletions t
      auto-save-file-name-transforms
      (list (list "\\`/[^/]*:\\([^/]*/\\)*\\([^/]*\\)\\'"
                  ;; Prefix tramp autosaves to prevent conflicts with local ones
                  (concat auto-save-list-file-prefix "tramp-\\2") t)
            (list ".*" auto-save-list-file-prefix t)))

;;; Scrolling
(setq hscroll-step 2
      hscroll-margin 5
      scroll-step 2
      scroll-margin 5
      scroll-conservatively 101
      scroll-preserve-screen-position 'always
      auto-window-vscroll nil
      fast-but-imprecise-scrolling t)

(setq-default scroll-up-aggressively 0.01
              scroll-down-aggressively 0.01)

(setq window-combination-resize t)

(setq recentf-max-saved-items 100)

;; Scroll pixel by pixel
(pixel-scroll-mode 1)

;; Window layout undo/redo (`winner-undo' / `winner-redo')
(winner-mode 1)

;; Highlight current line
(global-hl-line-mode 1)

;; Enable recentf-mode globally
(recentf-mode 1)

;; Save place in files
(save-place-mode 1)

;; Enable saving minibuffer history
;;(savehist-mode 1)

;; Show line and column numbers (cursor position) in mode-line
(line-number-mode 1)

;; Wrap long lines
(global-visual-line-mode 1)

;; Better handling for files with so long lines
(global-so-long-mode 1)

;; Global SubWord mode
(global-subword-mode 1)

;; Set Fullscreen
;; (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
;; (add-to-list 'default-frame-alist '(fullscreen . maximized))

;; ;; Set Transparency
;; (set-frame-parameter (selected-frame) 'alpha '(100 . 100))
;; (add-to-list 'default-frame-alist '(alpha . (100 . 100)))
#+end_src

** Emacs Behavior
*** Editing Text in Emacs
#+begin_src emacs-lisp
  ;; Change the user-emacs-directory to keep unwanted things out of ~/.emacs.d
  (setq user-emacs-directory (expand-file-name "~/.emacs.d/")
        url-history-file (expand-file-name "url/history" user-emacs-directory))
#+end_src

I *never* want to keep trailing spaces in my files, which is why I’m doing this:
#+begin_src emacs-lisp
(add-hook 'before-save-hook #'whitespace-cleanup)
(server-start)
#+end_src

I don’t understand why some people add two spaces behind a full stop, I sure don’t. Let’s tell Emacs.
#+begin_src emacs-lisp
(setq-default sentence-end-double-space nil)
#+end_src

Lastly, I want the default mode for Emacs to be Emacs Lisp.
#+begin_src emacs-lisp
(setq-default initial-major-mode 'emacs-lisp-mode)
#+end_src

*** Programming Modes
First off, my definition of what makes a “programming mode” doesn’t exactly fit mine, so on top of ~prog-mode~, let’s add a few other modes.
#+name: line-number-modes-table
| Modes      |
|------------|
| prog-mode  |
| latex-mode |

#+name: prog-modes-gen
#+header: :cache yes :exports none :tangle no
#+begin_src emacs-lisp :var modes=line-number-modes-table
(mapconcat (lambda (mode) (format "%s-hook" (car mode)))
           modes
           " ")
#+end_src

**** Line Number
Since version 26, Emacs has a built-in capacity of displaying line numbers on the left-side of the buffer. This is a fantastic feature that should actually be the default for all programming modes.

#+begin_src emacs-lisp
(dolist (mode '(<<prog-modes-gen()>>))
  (add-hook mode #'display-line-numbers-mode))
#+end_src

**** Folding code
Most programming languages can usually have their code folded, be it code between curly braces, chunks of comments or code on another level of indentation (Python, why…?). The minor-mode that enables that is ~hs-minor-mode~, let’s enable it for all of these programming modes:
#+begin_src emacs-lisp
(dolist (mode '(<<prog-modes-gen()>>))
  (add-hook mode #'hs-minor-mode))
#+end_src

*** Native Compilation
#+begin_src emacs-lisp
;; Silence compiler warnings as they can be pretty disruptive
(setq native-comp-async-report-warnings-errors nil)

;; Set the right directory to store the native comp cache
(add-to-list 'native-comp-eln-load-path (expand-file-name "eln-cache/" user-emacs-directory))
#+end_src

*** Stay Clean, Emacs!
As nice as Emacs is, it isn’t very polite or clean by default: open a file, and it will create backup files in the same directory. But then, when you open your directory with your favorite file manager and see almost all of your files duplicated with a =~= appended to the filename, it looks really uncomfortable! This is why I prefer to tell Emacs to keep its backup files to itself in a directory it only will access.
#+begin_src emacs-lisp
(setq backup-directory-alist `(("." . ,(expand-file-name ".tmp/backups/"
                                                         user-emacs-directory))))
#+end_src

It also loves to litter its ~init.el~ with custom variables here and there, but the thing is: I regenerate my ~init.el~ each time I tangle this file! How can I keep Emacs from adding stuff that will be almost immediately lost? Did someone say /custom file/?
#+begin_src emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" user-emacs-directory))
(when (file-exists-p custom-file) ; Don’t forget to load it, we still need it
  (load custom-file))
#+end_src

*** Stay Polite, Emacs!
When asking for our opinion on something, Emacs loves asking us to answer by “yes” or “no”, but *in full*! That’s very rude! Fortunately, we can fix this.
#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

This will make Emacs ask us for either hitting the ~y~ key for “yes”, or the ~n~ key for “no”. Much more polite!

It is also very impolite to keep a certain version of a file in its buffer when said file has changed on disk. Let’s change this behavior:
#+begin_src emacs-lisp
(global-auto-revert-mode 1)
#+end_src
*** Performance Upgrade
**** Emacs Startup
- Tính toán garbage collections khi khởi động Emacs và thời gian loaded.
#+begin_src emacs-lisp
;; Profile emacs startup
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "*** Emacs loaded in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+end_src

**** Keep .emacs.d Clean
#+begin_src emacs-lisp
  ;; Keep customization settings in a temporary file (thanks Ambrevar!)
  (setq custom-file
        (if (boundp 'server-socket-dir)
            (expand-file-name "custom.el" server-socket-dir)
          (expand-file-name (format "emacs-custom-%s.el" (user-uid)) temporary-file-directory)))
  (load custom-file t)
#+end_src

*** Fill Column
#+begin_src emacs-lisp
;; (defun dqv/org-mode-visual-fill ()
;;   (setq visual-fill-column-width 150
;;         visual-fill-column-center-text t)
;;   (visual-fill-column-mode 1))

;; (use-package visual-fill-column
;;   :straight (:build t)
;;   :hook (org-mode . dqv/org-mode-visual-fill))
#+end_src

** Personal Information
Emacs needs to know its master! For various reasons by the way, some packages rely of these variables to know who it is talking to or dealing with, such as ~mu4e~ which will guess who you are if you haven’t set it up correctly.
#+begin_src emacs-lisp
(setq user-full-name       "Dang Quang Vu"
      user-real-login-name "Dang Quang Vu"
      user-login-name      "jaydendang"
      user-mail-address    "jayden@openedu101.com")
#+end_src

** Visual Configuration
*** Basic
The first visual setting in this section will activate the visible bell. What it does is I get a visual feedback each time I do something Emacs doesn’t agree with, like tring to go up a line when I’m already at the top of the buffer.
#+begin_src emacs-lisp
(setq visible-bell t)
(setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
#+end_src

It is nicer to see a cursor cover the actual space of a character.
#+begin_src emacs-lisp
(setq x-stretch-cursor t)
#+end_src

When text is ellipsed, I want the ellipsis marker to be a single character of three dots. Let’s make it so:
#+begin_src emacs-lisp
(with-eval-after-load 'mule-util
 (setq truncate-string-ellipsis "…"))
#+end_src

*** Modeline Modules
I sometimes use Emacs in fullscreen, meaning my usual taskbar will be hidden. This is why I want the current date and time to be displayed, in an ISO-8601 style, although not exactly ISO-8601 (this is the best time format, fight me).
#+begin_src emacs-lisp
;; (require 'time)
;; (setq display-time-format "%Y-%m-%d %H:%M")
;; (display-time-mode 1) ; display time in modeline
#+end_src

Something my taskbar doesn’t have is a battery indicator. However, I want it enabled only if I am on a laptop or if a battery is available.
#+begin_src emacs-lisp
(let ((battery-str (battery)))
  (unless (or (equal "Battery status not available" battery-str)
              (string-match-p (regexp-quote "N/A") battery-str))
    (display-battery-mode 1)))
#+end_src

This isn’t a modeline module per se, but we have an indicator of the current line in Emacs. And although it is useful, I also often wish to know which column I’m on. This can be activated like so:
#+begin_src emacs-lisp
(column-number-mode)

;; Enable line numbers for some modes
(dolist (mode '(text-mode-hook
                prog-mode-hook
                conf-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 1))))

;; Override some modes which derive from the above
(dolist (mode '(org-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 0))))
#+end_src

The following code is, as will several chunks of code in this config, borrowed from [[https://tecosaur.github.io/emacs-config/#theme-modeline][TEC’s configuration]]. It hides the encoding information of the file if the file itself is a regular UTF-8 file with ~\n~ line ending. Be aware the ~doom-modeline-buffer-encoding~ variable is usabel here only because I use the Doom modeline as seen below.
#+begin_src emacs-lisp
(defun modeline-contitional-buffer-encoding ()
  "Hide \"LF UTF-8\" in modeline.

It is expected of files to be encoded with LF UTF-8, so only show
the encoding in the modeline if the encoding is worth notifying
the user."
  (setq-local doom-modeline-buffer-encoding
              (unless (and (memq (plist-get (coding-system-plist buffer-file-coding-system) :category)
                                 '(coding-category-undecided coding-category-utf-8))
                           (not (memq (coding-system-eol-type buffer-file-coding-system) '(1 2))))
                t)))
#+end_src

Now, let’s automate the call to this function in order to apply the modifications to the modeline each time we open a new file.
#+begin_src emacs-lisp
(add-hook 'after-change-major-mode-hook #'modeline-contitional-buffer-encoding)
#+end_src

*** Font
**** Set The Font
#+begin_src emacs-lisp
  (set-face-attribute 'default nil
                      ;; :font "JetBrains Mono"
                      :font "Victor Mono"
                      :weight 'regular
                      :height 135)

  ;; Set the fixed pitch face
  (set-face-attribute 'fixed-pitch nil
                      ;; :font "JetBrains Mono"
                      :font "Victor Mono"
                      :weight 'regular
                      :height 135)

  ;; Set the variable pitch face
  (set-face-attribute 'variable-pitch nil
                      ;; :font "Cantarell"
                      :font "Victor Mono"
                      :height 135
                      :weight 'light)
#+end_src

**** Emojis
#+begin_src emacs-lisp
  ;;(set-fontset-font t 'symbol "Noto Color Emoji")
  ;;(set-fontset-font t 'symbol "Symbola" nil 'append)

  (use-package emojify
    :straight (:build t)
    :custom
    (emojify-emoji-set "emojione-v2.2.6")
    (emojify-emojis-dir (concat user-emacs-directory "emojify/"))
    (emojify-display-style 'image)
    (emojify-download-emojis-p t)
    :config
    (global-emojify-mode 1))
#+end_src

*** Moody
#+begin_src emacs-lisp
;; Use moody for the mode bar
(use-package moody
  :straight (:build t)
  :config
  (setq x-underline-at-descent-line t)
  (moody-replace-mode-line-buffer-identification)
  (moody-replace-vc-mode))
#+end_src

*** Monions
#+begin_src emacs-lisp
(use-package minions
  :straight (:build t)
  :config
  (setq minions-mode-line-lighter ""
        minions-mode-line-delimiters '("" . ""))
  (minions-mode 1))
#+end_src

*** Cursor
#+begin_src emacs-lisp
(setq evil-insert-state-cursor '((bar . 2) "orange")
      evil-normal-state-cursor '(box "orange"))
#+end_src

** A better custom variable setter
Something people often forget about custom variables in Elisp is they can have a custom setter that will run some code if we set the variable properly with ~customize-set-variable~, so ~setq~ shouldn’t be the user’s choice by default. But repeatedly writing ~customize-set-variable~ can get tiring and boring. So why not take the best of both world and create ~csetq~, a ~setq~ that uses ~customize-set-variable~ under the hood while it keeps a syntax similar to the one ~setq~ uses?
#+begin_src emacs-lisp
(defmacro csetq (&rest forms)
  "Bind each custom variable FORM to the value of its VAL.

FORMS is a list of pairs of values [FORM VAL].
`customize-set-variable' is called sequentially on each pair
contained in FORMS. This means `csetq' has a similar behavior as
`setq': each VAL expression is evaluated sequentially, i.e., the
first VAL is evaluated before the second, and so on. This means
the value of the first FORM can be used to set the second FORM.

The return value of `csetq' is the value of the last VAL.

\(fn [FORM VAL]...)"
  (declare (debug (&rest sexp form))
           (indent 1))
  ;; Check if we have an even number of arguments
  (when (= (mod (length forms) 2) 1)
    (signal 'wrong-number-of-arguments (list 'csetq (1+ (length forms)))))
  ;; Transform FORMS into a list of pairs (FORM . VALUE)
  (let (sexps)
    (while forms
      (let ((form  (pop forms))
            (value (pop forms)))
        (push `(customize-set-variable ',form ,value)
              sexps)))
    `(progn ,@(nreverse sexps))))
#+end_src

** Visual
*** Fringe
It’s nice to know which lines were modified since the last commit in a file.
#+begin_src emacs-lisp
(use-package git-gutter-fringe
  :straight (:build t)
  :hook ((prog-mode     . git-gutter-mode)
         (org-mode      . git-gutter-mode)
         (markdown-mode . git-gutter-mode)
         (latex-mode    . git-gutter-mode))
  :config
  (setq git-gutter:update-interval 2)
  ;; These characters are used in terminal mode
  (setq git-gutter:modified-sign "≡")
  (setq git-gutter:added-sign "≡")
  (setq git-gutter:deleted-sign "≡")
  (set-face-foreground 'git-gutter:added "LightGreen")
  (set-face-foreground 'git-gutter:modified "LightGoldenrod")
  (set-face-foreground 'git-gutter:deleted "LightCoral"))
#+end_src

*** Icons? Did someone say icons?
/*YES! ALL OF THEM!*/

Ahem…

The package ~all-the-icons~ allows us to use a wide variety of icons in Emacs for various purposes, wherever we want, and /THAT/ is *GREAT*! I’ll (ab)use this feature in my config, be warned! *NOTE*: The first time a configuration with ~all-the-icons~ loads on a machine, the needed fonts might not be available, so you’ll need to install them with the command ~M-x all-the-icons-install-fonts~.
#+begin_src emacs-lisp
(use-package all-the-icons
  :defer t
  :straight t)
#+end_src

~prettify-symbols-mode~ is also a nifty feature of Emacs, and it is built-in! With that, I can replace strings of my choice by another character of my choice! First, let’s declare the general symbols that will be used everywhere.
#+begin_src emacs-lisp
(defun prog-mode-set-symbols-alist ()
  (setq prettify-symbols-alist '(("lambda"  . ?λ)
                                 ("null"    . ?∅)
                                 ("NULL"    . ?∅)))
  (prettify-symbols-mode 1))

(add-hook 'prog-mode-hook #'prog-mode-set-symbols-alist)
#+end_src

We can now take care of the language-specific symbols. First, let’s declare some symbols for the Lisp languages.
#+begin_src emacs-lisp
(setq-default lisp-prettify-symbols-alist '(("lambda"    . ?λ)
                                            ("defun"     . ?𝑓)
                                            ("defvar"    . ?𝑣)
                                            ("defcustom" . ?𝑐)
                                            ("defconst"  . ?𝐶)))

(defun lisp-mode-prettify ()
  (setq prettify-symbols-alist lisp-prettify-symbols-alist)
  (prettify-symbols-mode -1)
  (prettify-symbols-mode 1))

(dolist (lang '(emacs-lisp lisp common-lisp scheme))
  (add-hook (intern (format "%S-mode-hook" lang))
            #'lisp-mode-prettify))
#+end_src

Finally, similar to how ~org-appear~ behaves, let’s show the real string of our symbols when the cursor is on it.
#+begin_src emacs-lisp
(setq prettify-symbols-unprettify-at-point t)
#+end_src

*** Ligatures
The font I’m using  supports ligatures, but Emacs in GUI mode does not. And of course, there’s a package for that.
#+begin_src emacs-lisp
(use-package ligature
  :straight (ligature :type git
                      :host github
                      :repo "mickeynp/ligature.el"
                      :build t)
  :config
  (ligature-set-ligatures 't
                          '("www"))
  ;; Enable traditional ligature support in eww-mode, if the
  ;; `variable-pitch' face supports it
  (ligature-set-ligatures '(eww-mode org-mode elfeed-show-mode)
                          '("ff" "fi" "ffi"))
  ;; Enable all Cascadia Code ligatures in programming modes
  (ligature-set-ligatures 'prog-mode
                          '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                            ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                            "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                            "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                            "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                            "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                            "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                            "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                            ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                            "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                            "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                            "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                            "\\\\" "://"))
  (global-ligature-mode t))
#+end_src

*** Pixel-perfect alignment of Markdown and org-mode tables
Usually, I have no issue with the alignment of the tables I write in org-mode and (more rarely) Markdown. However, there are occurences where I’ll use a character that does not exactly respect my monospace font, which messes with the alignment of the table (often when I do linguistics stuff). A solution to this is the package ~valign~. A little caveat though, as its name implies ~valign~ helps with vertical alignment. If some lines are too high, they won’t exactly fit. Unless? Unless ~valign-fancy-bar~ is set to ~t~.

For now, I disabled the hook with org-mode and markdown-mode because it slows down opening these files quite a lot. I’ll re-enable the hook once it is fixed.
#+begin_src emacs-lisp
(use-package valign
  :defer t
  :straight (:build t)
  :after (org markdown-mode)
  :hook ((org-mode markdown-mode) . valign-mode)
  :custom ((valign-fancy-bar t)))
#+end_src

*** Solaire: Incandescent Emacs
A common issue when you have a lot of windows opened in Emacs is sometimes there’s just too much. Is the first window source code? Is the other one just an open email? Oh, let’s not forget the ~*Messages*~ buffer open next to another source buffer.

Solaire-mode applies a subtle but useful tweak to your current color scheme: the background of programming buffers is slightly lighter than the background of other buffers. (Or is it other buffers that have a slightly darker background? I’m not sure.)
#+begin_src emacs-lisp
(use-package solaire-mode
  :defer t
  :straight (:build t)
  :init (solaire-global-mode +1))
#+end_src

*** Custom Modus
**** Modus Theme
#+begin_src emacs-lisp
(use-package modus-themes
  ;; :straight (modus-themes :type built-in)
  :straight (:type git :host gitlab :repo "protesilaos/modus-themes" :branch "main")
  :init
  (setq modus-themes-italic-constructs t
        modus-themes-bold-constructs t
        modus-themes-mixed-fonts t
        modus-themes-variable-pitch-ui nil
        modus-themes-custom-auto-reload t
        modus-themes-disable-other-themes t
        modus-themes-common-palette-overrides '((bg-mode-line-active bg-yellow-subtle)
                                               ;; (bg-main #120B11)
                                                (border-mode-line-active yellow)
                                                (comment yellow-faint)
                                                (constant magenta-cooler)
                                                (docmarkup magenta-faint)
                                                (docstring green-faint)
                                                (fg-mode-line-active fg-main)
                                                (fnname magenta-warmer)
                                                ;; (fnname green-cooler)
                                                ;; (keyword cyan)
                                                (keyword yellow)
                                                (preprocessor cyan-cooler)
                                                (rx-backslash blue-cooler)
                                                (rx-construct magenta-warmer)
                                                (string green-cooler)
                                                (type magenta-cooler)
                                                (variable blue-warmer)
                                                (builtin magenta))
        modus-themes-completions '((matches . (extrabold))
                                   (selection . (semibold accented))
                                   (popup . (accented intense)))
        modus-themes-headings
        '((1 . (variable-pitch light 1.6))
          (2 . (overline semibold 1.5))
          (3 . (monochrome overline 1.4 background))
          (4 . (overline 1.3))
          (5 . (rainbow 1.2))
          (6 . (rainbow 1.15))
          (t . (rainbow 1.1)))))
#+end_src

**** Doom Themes
You may have noticed I use the Nord theme pretty much everywhere on my computer, why not Emacs? In my opinion, its aurora variant is nicer than the default Nord theme since it is richer in colors --- just a personal preference.
#+begin_src emacs-lisp
(add-to-list 'custom-theme-load-path (concat user-emacs-directory "themes/"))

(use-package doom-themes
  :straight (:build t)
  :ensure t
  :config
  ;; (load-theme 'catppuccin-latte t)
  ;; (load-theme 'catppuccin-frappe t)
  ;; (load-theme 'catppuccin-macchiato t)
  ;; (load-theme 'catppuccin-mocha t)
  ;; (load-theme 'rose-pine t)
  ;; (load-theme 'amarena t)
  ;; (load-theme 'oxocarbon t)
  ;; (load-theme 'kman t)
  ;; (load-theme 'kanagawa t)
  (load-theme 'doom-tokyo-night t)
  ;; (load-theme 'modus-vivendi t)
  (doom-themes-neotree-config)
  (doom-themes-org-config))
#+end_src

**** Nano Modeline
#+begin_src emacs-lisp
(use-package doom-modeline
  :straight t
  :custom
  (doom-modeline-height 35)
  (doom-modeline-bar-width 8)
  (doom-modeline-time-icon nil)
  (doom-modeline-buffer-encoding 'nondefault)
  (doom-modeline-unicode-fallback t)
  :config
  ;; FIX Add some padding to the right
  (doom-modeline-def-modeline 'main
    '(bar workspace-name window-number modals matches follow buffer-info
      remote-host buffer-position word-count parrot selection-info)
    '(objed-state misc-info persp-name battery grip irc mu4e gnus github debug
      repl lsp minor-modes input-method indent-info buffer-encoding major-mode
      process vcs checker time "   ")))
(setq evil-normal-state-tag   (propertize "[NORMAL]" 'face '((:background "lightgreen" :foreground "black")))
      evil-emacs-state-tag    (propertize "[EMACS]" 'face '((:background "yellow" :foreground "black")))
      evil-insert-state-tag   (propertize "[INSERT]" 'face '((:background "red") :foreground "white"))
      evil-motion-state-tag   (propertize "[MOTION]" 'face '((:background "blue") :foreground "white"))
      evil-visual-state-tag   (propertize "[VISUAL]" 'face '((:background "orange" :foreground "black")))
      evil-operator-state-tag (propertize "[OPERATOR]" 'face '((:background "purple"))))
#+end_src

*** Rainbow Delimiters
This makes Lisp especially more readable, but it’s also nice to have for any language that has delimiters like brackets too.
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :straight (:build t)
  :defer t
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

*** Y’all want some more /COLORS/?
It is possible to make info buffers much more colorful (and imo easier to read) with this simple package:
#+begin_src emacs-lisp
(use-package info-colors
  :straight (:build t)
  :commands info-colors-fnontify-node
  :hook (Info-selection . info-colors-fontify-node)
  :hook (Info-mode      . mixed-pitch-mode))
#+end_src

* Custom Elisp
** ~dqv/open-marked-files~
This function allows the user to open all marked files from a dired buffer as new Emacs buffers.
#+begin_src emacs-lisp
(defun dqv/open-marked-files (&optional files)
  "Open all marked FILES in Dired buffer as new Emacs buffers."
  (interactive)
  (let* ((file-list (if files
                        (list files)
                      (if (equal major-mode "dired-mode")
                          (dired-get-marked-files)
                        (list (buffer-file-name))))))
   (mapc (lambda (file-path)
           (find-file file-path))
         (file-list))))
#+end_src

** Handle new windows
The two functions below allow the user to not only create a new window
to the right or below the current window (respectively), but also to
focus the new window immediately.
#+begin_src emacs-lisp
(defun split-window-right-and-focus ()
  "Spawn a new window right of the current one and focus it."
  (interactive)
  (split-window-right)
  (windmove-right))

(defun jd/eldoc-and-focus ()
  "Spawn a new window right of the current one and focus it."
  (interactive)
  (eldoc-doc-buffer)
  (windmove-right))

(defun split-window-below-and-focus ()
  "Spawn a new window below the current one and focus it."
  (interactive)
  (split-window-below)
  (windmove-down))

(defun split-window-right-and-open-point ()
  "Spawn a new window right of the current one and focus it."
  (interactive)
  (split-window-right)
  (org-open-at-point))


(defun kill-buffer-and-delete-window ()
  "Kill the current buffer and delete its window."
  (interactive)
  (progn
    (kill-this-buffer)
    (delete-window)))

#+end_src

** Extend ~add-to-list~
One function I find missing regarding ~add-to-list~ is ~add-all-to-list~ so I can add multiple elements to a list at once. Instead, with vanilla Emacs, I have to repeatedly call ~add-to-list~. That’s not very clean. Let’s declare this missing function:
#+begin_src emacs-lisp
(defun add-all-to-list (list-var elements &optional append compare-fn)
  "Add ELEMENTS to the value of LIST-VAR if it isn’t there yet.

ELEMENTS is a list of values. For documentation on the variables
APPEND and COMPARE-FN, see `add-to-list'."
  (let (return)
    (dolist (elt elements return)
      (setq return (add-to-list list-var elt append compare-fn)))))
#+end_src

** Scroll page
#+begin_src emacs-lisp
(defun scroll-half-page-up ()
  "scroll down half the page"
  (interactive)
  (scroll-down (/ (window-body-height) 2)))

(defun scroll-half-page-down ()
  "scroll up half the page"
  (interactive)
  (scroll-up (/ (window-body-height) 2)))

#+end_src

** Switch to previous buffer
#+begin_src emacs-lisp
  (defun dqv/switch-to-previous-buffer ()
    "Switch to previously open buffer.
        Repeated invocations toggle between the two most recently open buffers."
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer) 1)))
#+end_src

** Move to beginning of live
#+begin_src emacs-lisp
 (defun my-smarter-move-beginning-of-line (arg)
   "Move point back to indentation of beginning of line.

        Move point to the first non-whitespace character on this line.
        If point is already there, move to the beginning of the line.
        Effectively toggle between the first non-whitespace character and
        the beginning of the line.

        If ARG is not nil or 1, move forward ARG - 1 lines first.  If
        point reaches the beginning or end of the buffer, stop there."
   (interactive "^p")
   (setq arg (or arg 1))

   ;; Move lines first
   (when (/= arg 1)
     (let ((line-move-visual nil))
        (forward-line (1- arg))))

   (let ((orig-point (point)))
     (back-to-indentation)
     (when (= orig-point (point))
        (move-beginning-of-line 1))))

 ;; remap C-a to `smarter-move-beginning-of-line'

#+end_src

** Go to match paren
#+begin_src emacs-lisp
(defun dqv/goto-match-paren (arg)
  "Go to the matching if on (){}[], similar to vi style of % ."
  (interactive "p")
  (cond ((looking-at "[\[\(\{]") (evil-jump-item))
        ((looking-back "[\]\)\}]" 1) (evil-jump-item))
        ((looking-at "[\]\)\}]") (forward-char) (evil-jump-item))
        ((looking-back "[\[\(\{]" 1) (backward-char) (evil-jump-item))
        (t nil)))
  (global-set-key (kbd "s-;") #'dqv/goto-match-paren)
#+end_src

** Delete This File
#+begin_src emacs-lisp
(defun dqv/delete-this-file (&optional trash)
  "Delete this file.

When called interactively, TRASH is t if no prefix argument is given.
With a prefix argument, TRASH is nil."
  (interactive)
  (when (and (called-interactively-p 'interactive)
             (not current-prefix-arg))
    (setq trash t))
  (if-let ((file (buffer-file-name)))
      (when (y-or-n-p "Delete this file? ")
        (delete-file file trash)
        (kill-buffer (current-buffer)))
    (user-error "Current buffer is not visiting a file")))
#+end_src

** Kill all the buffer
#+begin_src emacs-lisp
    (defun dqv/kill-other-buffers ()
      "Kill all other buffers."
      (interactive)
      (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))
#+end_src

* Keybinding Management
** Which-key
Which key is, I think, one of my favorite quality of life package. When you begin a keybind, Emacs will show you all keybinds you can follow the first one with in order to form a full keychord. Very useful when you have a lot of keybinds and don’t remember exactly what is what.
#+begin_src emacs-lisp
(use-package which-key
  :straight (:build t)
  :defer t
  :init (which-key-mode)
  :diminish which-key-mode
  :config
  (setq which-key-idle-delay 1))

(use-package which-key-posframe
  :config
  (which-key-posframe-mode))
#+end_src

** General
General is an awesome package for managing keybindings. Not only is it oriented towards keychords by default (which I love), but it also provides some integration with evil so that we can declare keybindings for certain states only! This is a perfect replacement for ~define-key~, ~evil-define-key~, and any other function for defining keychords. And it is also possible to declare a prefix for my keybindings! By default, all keybinds will be prefixed with ~SPC~ and keybinds related to a specific mode (often major modes) will be prefixed by a comma ~,~ (and by ~C-SPC~ and ~M-m~ respectively when in ~insert-mode~ or ~emacs-mode~).
#+begin_src emacs-lisp
(use-package general
  :straight (:build t)
  :init
  (general-auto-unbind-keys)
  :config
  (general-create-definer dqv/underfine
    :keymaps 'override
    :states '(normal emacs))
  (general-create-definer dqv/evil
    :states '(normal))
  (general-create-definer dqv/leader-key
    :states '(normal insert visual emacs)
    :keymaps 'override
    :prefix "SPC"
    :global-prefix "C-SPC")
  (general-create-definer dqv/major-leader-key
    :states '(normal insert visual emacs)
    :keymaps 'override
    :prefix ","
    :global-prefix "M-m"))
#+end_src

** Evil
*** Evil
Evil emulates most of vim’s keybinds, because let’s be honest here, they are much more comfortable than Emacs’.
#+begin_src emacs-lisp
(use-package evil
  :straight (:build t)
  :after (general)
  :init
  (setq evil-want-integration t
        evil-want-keybinding nil
        evil-want-C-u-scroll t
        evil-want-C-i-jump nil)
  (require 'evil-vars)
  (evil-set-undo-system 'undo-tree)
  :config
  <<evil-undefine-keys>>
  <<evil-bepo>>
  (evil-mode 1)
  (setq evil-want-fine-undo t) ; more granular undo with evil
  (evil-set-initial-state 'messages-buffer-mode 'normal)
  (evil-set-initial-state 'dashboard-mode 'normal))
#+end_src

*** Evil Define Keys
I want to undefine some of the default keybinds of Evil because it does not match my workflow. Namely, I use the space key and the comma as leaders for my keybinds, and I’m way too used to Emacs’ ~C-t~, ~C-a~, ~C-e~, and ~C-y~.
#+name: evil-undefine-keys
#+begin_src emacs-lisp :tangle no
(evil-global-set-key 'motion "j" 'evil-next-visual-line)
(evil-global-set-key 'motion "k" 'evil-previous-visual-line)
(evil-global-set-key 'motion "w" 'evil-avy-goto-word-1)
(global-set-key (kbd "s-'") #'evil-window-next)

(general-define-key
 :keymaps 'evil-motion-state-map
 "SPC" nil
 ","   nil)
(general-define-key
 :keymaps 'evil-insert-state-map
 "C-t" nil)
(general-define-key
 :keymaps 'evil-insert-state-map
 "U"   nil
 "C-a" nil
 "C-y" nil
 "C-e" nil)
#+end_src

*** For Colemak-keyboard
+ Something else that really bugs me is I use the jayden layout, which is not at all like the qwerty layout. For instance, ~hjkl~ becomes ~ctsr~. Thus, I need some jayden-specific changes.
#+name: evil-bepo
#+begin_src emacs-lisp :tangle no
;; (dolist (key '("c" "C" "t" "T" "s" "S" "r" "R" "h" "H" "j" "J" "k" "K" "l" "L"))
;;   (general-define-key :states 'normal key nil))

;; (general-define-key
;;  :states 'motion
;;  "h" 'evil-replace
;;  "H" 'evil-replace-state
;;  "j" 'evil-find-char-to
;;  "J" 'evil-find-char-to-backward
;;  "k" 'evil-substitute
;;  "K" 'evil-smart-doc-lookup
;;  "l" 'evil-change
;;  "L" 'evil-change-line

;;  "c" 'evil-backward-char
;;  "C" 'evil-window-top
;;  "t" 'evil-next-visual-line
;;  "T" 'evil-join
;;  "s" 'evil-previous-visual-line
;;  "S" 'evil-lookup
;;  "r" 'evil-forward-char
;;  "R" 'evil-window-bottom)
#+end_src

This package enables and integrates Evil into a lot of different modes, such as org-mode, dired, mu4e, etc. Again, I need some additional code compared to most people due to the jayden layout.
#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :straight (:build t)
    :config
    ;; jayden conversion
    ;; (defun my/jd-rotate-evil-collection (_mode mode-keymaps &rest _rest)
    ;;   (evil-collection-translate-key 'normal mode-keymaps
    ;;     ;; jd ctsr is qwerty hjkl
    ;;     "c" "h"
    ;;     "t" "j"
    ;;     "s" "k"
    ;;     "r" "l"
    ;;     ;; add back ctsr
    ;;     "h" "c"
    ;;     "j" "t"
    ;;     "k" "s"
    ;;     "l" "r"))
    ;; (add-hook 'evil-collection-setup-hook #'my/jd-rotate-evil-collection)
    (evil-collection-init))
#+end_src

~undo-tree~ is my preferred way of undoing and redoing stuff. The main reason is it doesn’t create a linear undo/redo history, but rather a complete tree you can navigate to see your complete editing history. One of the two obvious things to do are to tell Emacs to save all its undo history fies in a dedicated directory, otherwise we’d risk littering all of our directories. The second thing is to simply globally enable its mode.
#+begin_src emacs-lisp
(use-package undo-tree
  :defer t
  :straight (:build t)
  :custom
  (undo-tree-history-directory-alist
   `(("." . ,(expand-file-name (file-name-as-directory "undo-tree-hist")
                               user-emacs-directory))))
  :init
  (global-undo-tree-mode)
  :config
  <<undo-tree-ignore-text-properties>>
  ;; <<undo-tree-compress-files>>
  (setq undo-tree-visualizer-diff       t
        undo-tree-auto-save-history     t
        undo-tree-enable-undo-in-region t
        undo-limit        (* 800 1024)
        undo-strong-limit (* 12 1024 1024)
        undo-outer-limit  (* 128 1024 1024)))
#+end_src

An interesting behavior from DoomEmacs is to compress the history files with ~zstd~ when it is present on the system. Not only do we enjoy much smaller files (according to DoomEmacs, we get something like 80% file savings), Emacs can load them much faster than the regular files. Sure, it uses more CPU time uncompressing these files, but it’s insignificant and it’s still faster than loading a heavier file.
#+name: undo-tree-compress-files
#+begin_src emacs-lisp :tangle no
(when (executable-find "zstd")
  (defun my/undo-tree-append-zst-to-filename (filename)
    "Append .zst to the FILENAME in order to compress it."
    (concat filename ".zst"))
  (advice-add 'undo-tree-make-history-save-file-name
              :filter-return
              #'my/undo-tree-append-zst-to-filename))
#+end_src

** Hydra
[[https://github.com/abo-abo/hydra][Hydra]] is a simple menu creator for keybindings.
#+begin_src emacs-lisp
(use-package hydra
  :straight (:build t)
  :defer t)
#+end_src

Similarly still, this one allows me to manage the size my Emacs windows.
#+begin_src emacs-lisp
(defhydra windows-adjust-size ()
  "
^Zoom^                                ^Other
^^^^^^^-----------------------------------------
[_j_/_k_] shrink/enlarge vertically   [_q_] quit
[_l_/_h_] shrink/enlarge horizontally
"
  ("q" nil :exit t)
  ("l" shrink-window-horizontally)
  ("j" enlarge-window)
  ("k" shrink-window)
  ("h" enlarge-window-horizontally))
#+end_src

* Org-mode
*** Citeproc
Since recently, in order to make ~org-cite~ compile properly, we need the ~citeproc~ package, a citation processor.
#+begin_src emacs-lisp
(use-package citeproc
  :after (org)
  :defer t
  :straight (:build t))
#+end_src

*** Org
Org is the main reason I am using Emacs. It is an extremely powerfu tool when you want to write anything that is not necessarily primarily programming-related, though it absolutely can be! Org can be a replacement for anything similar to LibreOffice Writer, LibreOffice Calc, and LibreOffice Impress. It is a much more powerful (and older) version of Markdown which can be exported to LaTeX and HTML at least, rendering writing web pages and technical, scientific documents much simpler than writing manually HTML and LaTeX code, especially when a single document source is meant to be exported for both formats. And since org is an Emacs package, that also means it can be greatly extended however we like!
#+begin_src emacs-lisp
  (use-package org
    :straight t
    :defer t
    :commands (orgtbl-mode)
    :hook (org-mode . visual-line-mode)
           ;; (org-mode . org-num-mode))
    :custom-face
    (org-macro ((t (:foreground "#b48ead"))))
    :init
    (auto-fill-mode -1)
    :config
    <<org-hydra-babel>>
    (require 'ox-beamer)
    (require 'org-protocol)
    (setq org-hide-leading-stars             nil
          org-hide-macro-markers             t
          org-ellipsis                       " ⤵"
          org-image-actual-width             1200
          org-image-actual-height            1000
          org-redisplay-inline-images        t
          org-display-inline-images          t
          org-startup-with-inline-images     "inlineimages"
          org-pretty-entities                t
          org-fontify-whole-heading-line     t
          org-fontify-done-headline          t
          org-fontify-quote-and-verse-blocks t
          org-startup-indented               t
          org-startup-align-all-tables       t
          org-use-property-inheritance       t
          org-list-allow-alphabetical        t
          org-M-RET-may-split-line           nil
          org-src-window-setup               'split-window-right
          org-src-fontify-natively           t
          org-src-tab-acts-natively          t
          org-src-preserve-indentation       t
          org-log-done                       'time
          org-directory                      "~/Dropbox/Org"
          org-default-notes-file             (expand-file-name "notes.org" org-directory))
    (with-eval-after-load 'oc
     (setq org-cite-global-bibliography '("~/Dropbox/Org/bibliography/references.bib")))
    <<org-agenda-files>>
    <<org-behavior-electric>>
    <<org-capture-target-files>>
    <<org-capture-templates>>
    <<org-create-emphasis-functions()>>
    <<org-babel-load-languages>>
    <<org-use-sub-superscripts>>
    <<org-latex-compiler>>
    <<org-latex-src-block-backend>>
    <<org-latex-default-packages>>
    <<org-export-latex-hyperref-format>>
    <<org-latex-pdf-process>>
    <<org-latex-logfiles-add-extensions>>
    <<org-re-reveal>>
    <<org-html-validation>>
    <<org-latex-classes>>
    <<org-publish-projects>>
    :general
    (dqv/evil
      :keymaps 'org-mode-map
      :packages 'org
      "RET" 'org-open-at-point)
    (dqv/major-leader-key
      :keymaps 'org-mode-map
      :packages 'org
      ;; Various
      "RET" #'org-ctrl-c-ret
      "*" #'org-ctrl-c-star
      "'" #'org-edit-special
      "-" #'org-ctrl-c-minus
      "a" #'org-agenda
      "c" #'org-capture
      "C" #'org-columns
      "e" #'org-export-dispatch
      "l" #'org-store-link
      "p" #'org-priority
      "r" #'org-reload
      ;; Babels
      "b" '(:ignore t :which-key "babel")
      "b." #'org-babel-transient/body
      "bb" #'org-babel-execute-buffer
      "bc" #'org-babel-check-src-block
      "bC" #'org-babel-tangle-clean
      "be" #'org-babel-execute-maybe
      "bf" #'org-babel-tangle-file
      "bn" #'org-babel-next-src-block
      "bo" #'org-babel-open-src-block-result
      "bp" #'org-babel-previous-src-block
      "br" #'org-babel-remove-result-one-or-many
      "bR" #'org-babel-goto-named-result
      "bt" #'org-babel-tangle
      "bi" #'org-babel-view-src-block-info
      ;; Dates
      "d" '(:ignore t :which-key "Dates")
      "dd" #'org-deadline
      "ds" #'org-schedule
      "dt" #'org-time-stamp
      "dT" #'org-time-stramp-inactive
      ;; Insert
      "i" '(:ignore t :which-key "Insert")
      "ib" #'org-insert-structure-template
      "id" #'org-insert-drawer
      "ie" '(:ignore t :which-key "Emphasis")
      "ieb" #'org-emphasize-bold
      "iec" #'org-emphasize-code
      "iei" #'org-emphasize-italic
      "ies" #'org-emphasize-strike-through
      "ieu" #'org-emphasize-underline
      "iev" #'org-emphasize-verbatim
      "iE" #'org-set-effort
      "if" #'org-footnote-new
      "ih" #'org-insert-heading
      "iH" #'counsel-org-link
      "ii" #'org-insert-item
      "il" #'org-insert-link
      "in" #'org-add-note
      "ip" #'org-set-property
      "is" #'org-insert-subheading
      "it" #'org-set-tags-command
      ;; Tables
      "t" '(:ignore t :which-key "Table")
      "th" #'org-table-move-column-left
      "tj" #'org-table-move-row-down
      "tk" #'org-table-move-row-up
      "tl" #'org-table-move-column-right
      "ta" #'org-table-align
      "te" #'org-table-eval-formula
      "tf" #'org-table-field-info
      "tF" #'org-table-edit-formulas
      "th" #'org-table-convert
      "tl" #'org-table-recalculate
      "tp" #'org-plot/gnuplot
      "tS" #'org-table-sort-lines
      "tw" #'org-table-wrap-region
      "tx" #'org-table-shrink
      "tN" #'org-table-create-with-table.el
      "td" '(:ignore t :which-key "Delete")
      "tdc" #'org-table-delete-column
      "tdr" #'org-table-kill-row
      "ti" '(:ignore t :which-key "Insert")
      "tic" #'org-table-insert-column
      "tih" #'org-table-insert-hline
      "tir" #'org-table-insert-row
      "tiH" #'org-table-hline-and-move
      "tt" '(:ignore t :which-key "Toggle")
      "ttf" #'org-table-toggle-formula-debugger
      "tto" #'org-table-toggle-coordinate-overlays
      ;; Toggle
      "T" '(:ignore t :which-key "Toggle")
      "Tc" #'org-toggle-checkbox
      "Ti" #'org-toggle-inline-images
      "Tl" #'org-latex-preview
      "Tn" #'org-num-mode
      "Ts" #'dqv/toggle-org-src-window-split
      "Tt" #'org-show-todo-tree
      "<SPC>" #'org-todo
      )


    <<org-capture-keybinds>>
    (dqv/major-leader-key
      :packages 'org
      :keymaps 'org-src-mode-map
      "'" #'org-edit-src-exit
      "k" #'org-edit-src-abort))
#+end_src

#+begin_src emacs-lisp
(defun dqv/my-open-urls-in-region (beg end)
  "Open URLs between BEG and END.
        TODO: Get better at detecting and opening all URLs"
  (interactive "r")
  (save-excursion
    (save-restriction
      (narrow-to-region beg end)
      (goto-char (point-min))
      (while (re-search-forward org-any-link-re nil t)
        (save-excursion
          (backward-char)
          (org-open-at-point))))))
#+end_src

*** Evil Org
The main feature from ~evil-org~ that I love is how easy it is to modify some keybindings for keyboards layouts that do not have ~hjkl~, such as the jd layout (or Dvorak or Colemak if you are into that). But it also adds a ton of default keybindings which are just much more comfortable than the default ones you get with evil and org naked.
#+begin_src emacs-lisp
  (use-package evil-org
    :straight (:build t)
    :after (org)
    :hook (org-mode . evil-org-mode)
    :config
    (setq-default evil-org-movement-bindings
                  '((up    . "k")
                    (down  . "j")
                    (left  . "h")
                    (right . "l")))
    (evil-org-set-key-theme '(textobjects navigation calendar additional shift operators))
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys))
#+end_src

*** Contrib
Since very recently, the ~contrib/lisp/~ directory of org moved out of the main repository to [[https://git.sr.ht/~bzg/org-contrib][this repository]]. On the other hand, ~contrib/scripts/~ moved to [[https://code.orgmode.org/bzg/worg/src/master/code][the worg repository]], but I don’t need it. The main reason I want ~org-contrib~ is due to ~ox-extra~ that allow the usage of the ~:ignore:~ tag in org.
#+begin_src emacs-lisp
(use-package org-contrib
  :after (org)
  :defer t
  :straight (:build t)
  :init
  (require 'ox-extra)
  (ox-extras-activate '(latex-header-blocks ignore-headlines)))
#+end_src

*** Agenda
#+name: org-agenda-files
#+begin_src emacs-lisp :tangle no :exports code :results silent
(setq org-agenda-files (list "~/Dropbox/Org/" "~/Dropbox/Roam/" "~/Dropbox/Roam/blockchain/" "~/Dropbox/Roam/daily"))
#+end_src

*** Babel
One of the amazing features of org-mode is its literary programming capacities
by running code blocks from within Org-mode itself. But for that, only a couple
of languages are supported directly by Org-mode itself, and they need to be
activated. Here are the languages I activated in my Org-mode configuration:
#+NAME: org-babel-languages-table
| C          |
| emacs-lisp |
| gnuplot    |
| latex      |
| makefile   |
| restclient |
| js         |
| plantuml   |
| python     |
| sass       |
| shell      |
| sql        |

#+NAME: org-babel-languages-gen
#+header: :cache yes :results replace
#+header: :var languages=org-babel-languages-table[,0]
#+BEGIN_SRC emacs-lisp :exports none :tangle no
(format "'(%s)"
        (mapconcat (lambda ($language)
                     (format "(%s . t)" $language))
                   languages
                   "\n  "))
#+END_SRC

#+RESULTS[4f5f1e3b7e6c7deff167ce33bc7d4c6c2c52d873]: org-babel-languages-gen
#+begin_example
'((C . t)
  (emacs-lisp . t)
  (gnuplot . t)
  (latex . t)
  (makefile . t)
  (js . t)
  (plantuml . t)
  (restclient . t)
  (python . t)
  (sass . t)
  (shell . t)
  (sql . t))
#+end_example

The corresponding code is as follows:
#+NAME: org-babel-load-languages
#+BEGIN_SRC emacs-lisp :noweb yes :tangle no
(org-babel-do-load-languages
 'org-babel-load-languages
 <<org-babel-languages-gen()>>)
#+END_SRC

Some languages can run asynchronously with the help of ~ob-async~.
#+begin_src emacs-lisp
(use-package ob-async
  :straight (:build t)
  :defer t
  :after (org ob))
#+end_src

A package I use from time to time is ~ob-latex-as-png~ which allows me to easily convert a LaTeX snippet into a PNG, regardless of the exporter I use afterwards. Its installation is pretty simple:
#+begin_src emacs-lisp
(use-package ob-latex-as-png
  :after org
  :straight (:build t))
#+end_src

A nice thing to have when working with REST APIs is to have a REST client. Even better if it can work inside org-mode!
#+begin_src emacs-lisp
(use-package restclient
  :straight (:build t)
  :defer t)

(use-package ob-restclient
  :straight (:build t)
  :defer t
  :after (org ob)
  :init
  (add-to-list 'org-babel-load-languages '(restclient . t)))
#+end_src

*** Behavior
A useful package I like is ~toc-org~ which creates automatically a table of contents. My main usage for this however is not just to create a table of content of my files to quickly jump around my file (I have ~counsel-org-goto~ for that), but it is for creating table of contents for org files that will be hosted and viewable on Github.
#+begin_src emacs-lisp
(use-package toc-org
  :straight (:build t)
  :after (org)
  :init
  (add-to-list 'org-tag-alist '("TOC" . ?T))
  :hook (org-mode . toc-org-mode)
  :hook (org-mode . toc-org-enable)
  :hook (markdown-mode . toc-org-enable))
#+end_src

~electric-mode~ also bothers me a lot when editing org files, so let’s deactivate it:
#+name: org-behavior-electric
#+begin_src emacs-lisp :tangle no
(add-hook 'org-mode-hook (lambda ()
                           (interactive)
                           (electric-indent-local-mode -1)))
#+end_src

*** Capture
Org capture is an amazing tool for taking quick notes, be it simple text, links, resources, or reminders. They are all organised is specified org files which are described below.
#+name: org-capture-target-files
#+begin_src emacs-lisp :tangle no
(defvar org-personal-file "~/Dropbox/Org/Personal.org")
(defvar org-vocabulary-file "~/Dropbox/Org/Vocabulary.org")
#+end_src

Let me describe a keybind to invoke org-capture from anywhere within Emacs.
#+name: org-capture-keybinds
#+begin_src emacs-lisp :tangle no
(dqv/leader-key
  :packages 'org
  :infix "o"
  ""  '(:ignore t :which-key "org")
  "c" #'org-capture)
#+end_src

When ~org-capture~ is invoked, it will ask which template we wish to use. In the table [[org-capture-shortcuts-table]], the /key/ column represents which keychord we need to hit, titled with /name/, we need to hit in order to use the /template/, inserted in the designated /file/ in the manner described by /insertion mode/.
#+name: org-capture-shortcuts-table
| Shortcut | Name       | Title | Insertion mode | file                | template              |
|----------+------------+-------+----------------+---------------------+-----------------------|
| p        | Personal   |       | file+headline  | org-personal-file   | schedule.orgcaptmpl   |
| v        | Vocabulary |       |                | org-vocabulary-file | vocabulary.orgcaptmpl |

#+name: org-capture-shortcuts-gen
#+header: :exports none :cache yes :tangle no
#+begin_src emacs-lisp :var entries=org-capture-shortcuts-table
(mapconcat (lambda (entry)
             (let ((key      (nth 0 entry))
                   (name     (nth 1 entry))
                   (title    (nth 2 entry))
                   (ins-mode (nth 3 entry))
                   (file     (nth 4 entry))
                   (template (nth 5 entry)))
               (if (string= "" ins-mode)
                   (format "%S" `(,key ,name))
                 (format "(\"%s\" \"%s\" entry\n  %S\n  %S)"
                         key name
                         `(,(intern ins-mode) ,(intern file) ,(if (string= "file+datetree" ins-mode)
                                                                  (intern "")
                                                                (if (string= title "")
                                                                    name
                                                                  title)))
                         `(file ,(concat "~/.emacs.d/capture/" template))))))
           entries
           "\n")
#+end_src

#+RESULTS[7643b4af0bad2d5e1349d3722e8c5348fe77bb81]: org-capture-shortcuts-gen
#+begin_example
("a" "Archive")
("aw" "Web" entry
  (file+headline org-archive-file "Websites")
  (file "~/.emacs.d/capture/schedule.orgcaptmpl"))
("ar" "Research" entry
  (file+headline org-archive-file "Research")
  (file "~/.emacs.d/capture/schedule.orgcaptmpl"))
("aq" "Quote" entry
  (file+headline org-archive-file "Quote")
  (file "~/.emacs.d/capture/schedule.orgcaptmpl"))
("ad" "Development" entry
  (file+headline org-archive-file "Development")
  (file "~/.emacs.d/capture/schedule.orgcaptmpl"))
("i" "Ideas" entry
  (file+headline org-archive-file "Ideas")
  (file "~/.emacs.d/capture/ideas.orgcaptmpl"))
("j" "Journal" entry
  (file+headline org-journal-file "Journal")
  (file "~/.emacs.d/capture/schedule.orgcaptmpl"))
("t" "Training" entry
  (file+headline org-training-file "Training")
  (file "~/.emacs.d/capture/schedule.orgcaptmpl"))
("s" "Study" entry
  (file+headline org-study-file "Study")
  (file "~/.emacs.d/capture/schedule.orgcaptmpl"))
("v" "Vocabulary" entry
  (file+headline org-vocabulary-file "Vocabulary")
  (file "~/.emacs.d/capture/vocabulary.orgcaptmpl"))
("St" "Tiktok" entry
  (file+headline org-social-file "Tiktok")
  (file "~/.emacs.d/capture/schedule.orgcaptmpl"))
("ST" "Tweeter" entry
  (file+headline org-social-file "Tweeter")
  (file "~/.emacs.d/capture/schedule.orgcaptmpl"))
("Sl" "Linkedin" entry
  (file+headline org-social-file "Linkedin")
  (file "~/.emacs.d/capture/schedule.orgcaptmpl"))
("Sb" "Blog" entry
  (file+headline org-social-file "Posts")
  (file "~/.emacs.d/capture/schedule.orgcaptmpl"))
("w" "Work" entry
  (file+headline org-work-file "Work")
  (file "~/.emacs.d/capture/schedule.orgcaptmpl"))
("p" "Personal" entry
  (file+headline org-personal-file "Personal")
  (file "~/.emacs.d/capture/schedule.orgcaptmpl"))
#+end_example

The capture templates are set like so:
#+name: org-capture-templates
#+begin_src emacs-lisp :tangle no :results silent
(setq org-capture-templates
      '(
        <<org-capture-shortcuts-gen()>>))
#+end_src

*** Custom functions
**** Emphasize text
Sometimes, I want to emphasize some text in my org-mode documents. It’s very possible to just go to the begining of the chosen text, add the marker, then go to the end of the text than needs emphasis and add another marker, and I’m sure most people are fine with that. But I also like being able to select a region and hit a keybind to emphasize it that way. The table [[org-emphasis-character]] lists the emphasis characters in org-mode, their role, and the character code of each emphasis character. From that, creating functions that emphasize a selected text is quite easy.

#+name: org-emphasis-character
| Emphasis       | Character | Character code |
|----------------+-----------+----------------|
| bold           | ~*~         |             42 |
| italic         | ~/~         |             47 |
| underline      | ~_~         |             95 |
| verbatim       | ~=~         |             61 |
| code           | ~~~         |            126 |
| strike-through | ~+~         |             43 |

#+name: org-create-emphasis-functions
#+header: :tangle no :exports results :cache yes
#+header: :wrap "src emacs-lisp :tangle no :exports code"
#+begin_src emacs-lisp :var emphasis-list=org-emphasis-character
(mapconcat (lambda (emphasis)
             (let ((type (car emphasis))
                   (code (nth 2 emphasis)))
               (format "(defun org-emphasize-%s ()
  \"Emphasize as %s the current region.\"
  (interactive)
  (org-emphasize %s))"
                       type
                       type
                       code)))
           emphasis-list
           "\n")
#+end_src

#+RESULTS[dbd10cce4ae05a046838214784f0f4c16765e728]: org-create-emphasis-functions
#+begin_src emacs-lisp :tangle no :exports code
(defun org-emphasize-bold ()
  "Emphasize as bold the current region."
  (interactive)
  (org-emphasize 42))
(defun org-emphasize-italic ()
  "Emphasize as italic the current region."
  (interactive)
  (org-emphasize 47))
(defun org-emphasize-underline ()
  "Emphasize as underline the current region."
  (interactive)
  (org-emphasize 95))
(defun org-emphasize-verbatim ()
  "Emphasize as verbatim the current region."
  (interactive)
  (org-emphasize 61))
(defun org-emphasize-code ()
  "Emphasize as code the current region."
  (interactive)
  (org-emphasize 126))
(defun org-emphasize-strike-through ()
  "Emphasize as strike-through the current region."
  (interactive)
  (org-emphasize 43))
#+end_src

You can find the keybinds for these functions in the chapter
§[[#Packages-Configuration-Org-mode-Keybindingsv0e5fl6184j0]].

**** ~dqv/toggle-org-src-window-split~
#+begin_src emacs-lisp
(defun dqv/toggle-org-src-window-split ()
  "This function allows the user to toggle the behavior of
`org-edit-src-code'. If the variable `org-src-window-setup' has
the value `split-window-right', then it will be changed to
`split-window-below'. Otherwise, it will be set back to
`split-window-right'"
  (interactive)
  (if (equal org-src-window-setup 'split-window-right)
      (setq org-src-window-setup 'split-window-below)
    (setq org-src-window-setup 'split-window-right))
  (message "Org-src buffers will now split %s"
           (if (equal org-src-window-setup 'split-window-right)
               "vertically"
             "horizontally")))
#+end_src

*** Exporters
I want to disable by default behavior of ~^~ and ~_~ for only one character, making it compulsory to use instead ~^{}~ and ~_{}~ respectively. This is due to my frequent usage of the underscore in my org files as a regular character and not a markup one, especially when describing phonetics evolution. So, let’s disable it:
#+NAME: org-use-sub-superscripts
#+BEGIN_SRC emacs-lisp :tangle no
(setq org-use-sub-superscripts (quote {}))
#+END_SRC

**** Epub
A backend for exporting files through org I like is ~ox-epub~ which, as you can guess, exports org files to the [[https://www.w3.org/publishing/epub32/][Epub format]].
#+begin_src emacs-lisp
(use-package ox-epub
  :after (org ox)
  :straight (:build t))
#+end_src

**** Gemini
#+begin_src emacs-lisp
(use-package ox-gemini
  :defer t
  :straight (:build t)
  :after (ox org))
#+end_src

**** HTML
On HTML exports, Org-mode tries to include a validation link for the exported HTML. Let’s disable that since I never use it.
#+NAME: org-html-validation
#+BEGIN_SRC emacs-lisp :tangle no
(setq org-html-validation-link nil)
#+END_SRC

#+begin_src emacs-lisp
;; (use-package htmlize
;;   :defer t
;;   :straight (:build t))
#+end_src

This package allows for live-previewing the HTML export of an org
buffer in an XWidget Webkit browser window. But when testing it, it’s
not great for large org files, I should keep its usage for smaller org
files.
#+begin_src emacs-lisp
(use-package preview-org-html-mode
  :defer t
  :after (org)
  :straight (preview-org-html-mode :build t
                                   :type git
                                   :host github
                                   :repo "jakebox/preview-org-html-mode")
  :general
  (dqv/major-leader-key
   :keymaps 'org-mode-map
   :packages 'preview-org-html-mode
   :infix "P"
   ""  '(:ignore t :which-key "preview")
   "h" #'preview-org-html-mode
   "r" #'preview-org-html-refresh
   "p" #'preview-org-html-pop-window-to-frame)
  :config
  (setq preview-org-html-refresh-configuration 'save))
#+end_src

**** LaTeX
When it comes to exports, I want the LaTeX and PDF exports to be done with XeLaTeX only. This implies the modification of the following variable:
#+NAME: org-latex-compiler
#+BEGIN_SRC emacs-lisp :tangle no
(setq org-latex-compiler "xelatex")
#+END_SRC

A new backend that was introduced in org-mode for LaTeX source block coloring is ~engraved~.
#+BEGIN_SRC emacs-lisp
(use-package engrave-faces
  :defer t
  :straight (:build t)
  :after org)
#+END_SRC

#+name: org-latex-src-block-backend
#+begin_src emacs-lisp :tangle no
(require 'engrave-faces)
(csetq org-latex-src-block-backend 'engraved)
#+end_src

The default packages break my LaTeX exports: for some reasons, images are not loaded and exported in PDFs, so I needed to redifine the default packages excluding the one that broke my exports; namely, I need to remove ~inputenc~, ~fontenc~ and ~grffile~. I also added some default packages:
- ~cleveref~ for better references to various elements.
- ~svg~ for inserting SVG files in PDF outputs
- ~booktabs~ for nicer tables
- and ~tabularx~ for tabulars with adjustable columns
#+NAME: org-latex-default-packages
#+BEGIN_SRC emacs-lisp :tangle no
(dolist (package '(("AUTO" "inputenc" t ("pdflatex"))
                   ("T1"   "fontenc"  t ("pdflatex"))
                   (""     "grffile"  t)))
  (delete package org-latex-default-packages-alist))

(dolist (package '(("capitalize" "cleveref")
                   (""           "booktabs")
                   (""           "tabularx")))
  (add-to-list 'org-latex-default-packages-alist package t))

(setq org-latex-reference-command "\\cref{%s}")
#+END_SRC

By the way, reference links in LaTeX should be written in this format,
since we are using ~cleveref~:
#+NAME: org-export-latex-hyperref-format
#+BEGIN_SRC emacs-lisp :tangle no
(setq org-export-latex-hyperref-format "\\ref{%s}")
#+END_SRC

[[https://tectonic-typesetting.github.io/en-US/][Tectonic]] is awesome for processing LaTeX documents! Look how simple it
is!
#+NAME: org-latex-pdf-process
#+BEGIN_SRC emacs-lisp :tangle no
;; (setq org-latex-pdf-process
;;       '("tectonic -Z shell-escape --synctex --outdir=%o %f"))
(setq org-latex-pdf-process '("%latex -shell-escape -interaction nonstopmode -output-directory %o %f"
            "%bibtex -output-directory %o %f"
            "%latex -shell-escape -interaction nonstopmode -output-directory %o %f"
            "%latex -shell-escape -interaction nonstopmode -output-directory %o %f")
      org-latex-remove-logfiles t
      org-latex-logfiles-extensions '("aux" "bcf" "blg" "fdb_latexmk" "fls"
              "figlist" "idx" "log" "nav" "out" "ptc"
              "run.xml" "snm" "toc" "vrb" "xdv"))
#+END_SRC

Finally, org-mode is supposed to automatically clean logfiles after it
exports an org file to LaTeX. However, it misses a few, so I need to
add their extension like so:
#+name: org-latex-logfiles-add-extensions
#+begin_src emacs-lisp :tangle no
(dolist (ext '("bbl" "lot"))
  (add-to-list 'org-latex-logfiles-extensions ext t))
#+end_src

**** Reveal.js
#+NAME: org-re-reveal
#+begin_src emacs-lisp
(use-package org-re-reveal
  :defer t
  :after org
  :straight (:build t)
  :init
  (add-hook 'org-mode-hook (lambda () (require 'org-re-reveal)))
  :config
  (setq org-re-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js"
        org-re-reveal-revealjs-version "4"))
#+end_src

**** SSH Config
Yet another exporter I enjoy is [[https://github.com/dantecatalfamo/ox-ssh][~ox-ssh~]] with which I manage my ~$HOME/.ssh/config~ file. You won’t find my org file for managing my servers on my repos though.
#+begin_src emacs-lisp
(use-package ox-ssh
  :after (ox org)
  :straight (:build t))
#+end_src

*** Keybindings
Be prepared, I have a lot of keybindings for org-mode! They are all prefixed with a comma ~,~ in normal mode.
#+name: org-keybinds-various
| Key chord | Function            | Description |
|-----------+---------------------+-------------|
| RET       | org-ctrl-c-ret      |             |
| *         | org-ctrl-c-star     |             |
| ,         | org-ctrl-c-ctrl-c   |             |
| '         | org-edit-special    |             |
| -         | org-ctrl-c-minus    |             |
| a         | org-agenda          |             |
| c         | org-capture         |             |
| C         | org-columns         |             |
| e         | org-export-dispatch |             |
| l         | org-store-link      |             |
| p         | org-priority        |             |
| r         | org-reload          |             |


I then have a couple of babel-related functions.
#+name: org-keybinds-babel
| Key chord | Function                            | Description |
|-----------+-------------------------------------+-------------|
| b         | nil                                 | babel       |
| b.        | org-babel-transient/body            |             |
| bb        | org-babel-execute-buffer            |             |
| bc        | org-babel-check-src-block           |             |
| bC        | org-babel-tangle-clean              |             |
| be        | org-babel-execute-maybe             |             |
| bf        | org-babel-tangle-file               |             |
| bn        | org-babel-next-src-block            |             |
| bo        | org-babel-open-src-block-result     |             |
| bp        | org-babel-previous-src-block        |             |
| br        | org-babel-remove-result-one-or-many |             |
| bR        | org-babel-goto-named-result         |             |
| bt        | org-babel-tangle                    |             |
| bi        | org-babel-view-src-block-info       |             |

The ~org-babel-transient~ hydra allows me to quickly navigate between
code blocks and interact with them. This code block was inspired by
one you can find in Spacemacs.
#+name: org-hydra-babel
#+begin_src emacs-lisp :tangle no
(defhydra org-babel-transient ()
  "
^Navigate^                    ^Interact
^^^^^^^^^^^------------------------------------------
[_j_/_k_] navigate src blocs  [_x_] execute src block
[_g_]^^   goto named block    [_'_] edit src block
[_z_]^^   recenter screen     [_q_] quit
"
  ("q" nil :exit t)
  ("j" org-babel-next-src-block)
  ("k" org-babel-previous-src-block)
  ("g" org-babel-goto-named-src-block)
  ("z" recenter-top-bottom)
  ("x" org-babel-execute-maybe)
  ("'" org-edit-special :exit t))
#+end_src

We next have keybindings related to org-mode’s agenda capabilities. We
can schedule a todo header for some dates, or set a deadline.
#+name: org-keybinds-dates
| Key chord | Function                | Description |
|-----------+-------------------------+-------------|
| d         | nil                     | dates       |
| dd        | org-deadline            |             |
| ds        | org-schedule            |             |
| dt        | org-time-stamp          |             |
| dT        | org-time-stamp-inactive |             |

Let’s now define some keybinds for inserting stuff in our org buffer:
#+name: org-keybinds-insert
| Key chord | Function                      | Description |
|-----------+-------------------------------+-------------|
| i         | nil                           | insert      |
| ib        | org-insert-structure-template |             |
| id        | org-insert-drawer             |             |
| ie        | nil                           | emphasis    |
| ieb       | org-emphasize-bold            |             |
| iec       | org-emphasize-code            |             |
| iei       | org-emphasize-italic          |             |
| ies       | org-emphasize-strike-through  |             |
| ieu       | org-emphasize-underline       |             |
| iev       | org-emphasize-verbatim        |             |
| iE        | org-set-effort                |             |
| if        | org-footnote-new              |             |
| ih        | org-insert-heading            |             |
| iH        | counsel-org-link              |             |
| ii        | org-insert-item               |             |
| il        | org-insert-link               |             |
| in        | org-add-note                  |             |
| ip        | org-set-property              |             |
| is        | org-insert-subheading         |             |
| it        | org-set-tags-command          |             |


Tables get a bit more love:
#+name: org-keybinds-tables
| Key chord | Function                             | Description |
|-----------+--------------------------------------+-------------|
| t         | nil                                  | tables      |
| th        | org-table-move-column-left           |             |
| tj        | org-table-move-row-down              |             |
| tk        | org-table-move-row-up                |             |
| tl        | org-table-move-column-right          |             |
| ta        | org-table-align                      |             |
| te        | org-table-eval-formula               |             |
| tf        | org-table-field-info                 |             |
| tF        | org-table-edit-formulas              |             |
| th        | org-table-convert                    |             |
| tl        | org-table-recalculate                |             |
| tp        | org-plot/gnuplot                     |             |
| tS        | org-table-sort-lines                 |             |
| tw        | org-table-wrap-region                |             |
| tx        | org-table-shrink                     |             |
| tN        | org-table-create-with-table.el       |             |
| td        | nil                                  | delete      |
| tdc       | org-table-delete-column              |             |
| tdr       | org-table-kill-row                   |             |
| ti        | nil                                  | insert      |
| tic       | org-table-insert-column              |             |
| tih       | org-table-insert-hline               |             |
| tir       | org-table-insert-row                 |             |
| tiH       | org-table-hline-and-move             |             |
| tt        | nil                                  | toggle      |
| ttf       | org-table-toggle-formula-debugger    |             |
| tto       | org-table-toggle-coordinate-overlays |             |

Finally, let’s make enabling and disabling stuff accessible:
#+name: org-keybinds-toggles
| Key chord | Function                        | Description |
|-----------+---------------------------------+-------------|
| T         | nil                             | toggle      |
| Tc        | org-toggle-checkbox             |             |
| Ti        | org-toggle-inline-images        |             |
| Tl        | org-latex-preview               |             |
| Tn        | org-num-mode                    |             |
| Ts        | dqv/toggle-org-src-window-split |             |
| Tt        | org-show-todo-tree              |             |
| <SPC>     | org-todo                        |             |

*** LaTeX formats
I currently have two custom formats for my Org-mode exports: one for general use (initialy for my conlanging files, hence its ~conlang~ name), and one for beamer exports.

Below is the declaration of the ~conlang~ LaTeX class:
#+NAME: org-latex-class-conlang
#+BEGIN_SRC emacs-lisp
'("conlang"
  "\\documentclass{book}"
  ("\\chapter{%s}" . "\\chapter*{%s}")
  ("\\section{%s}" . "\\section*{%s}")
  ("\\subsection{%s}" . "\\subsection*{%s}")
  ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
#+END_SRC

And here is the declaration of the ~beamer~ class:
#+NAME: org-latex-class-beamer
#+BEGIN_SRC emacs-lisp
`("beamer"
  ,(concat "\\documentclass[presentation]{beamer}\n"
           "[DEFAULT-PACKAGES]"
           "[PACKAGES]"
           "[EXTRA]\n")
  ("\\section{%s}" . "\\section*{%s}")
  ("\\subsection{%s}" . "\\subsection*{%s}")
  ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
#+END_SRC

Both these classes have to be added to ~org-latex-classes~ like so:
#+NAME: org-latex-classes
#+BEGIN_SRC emacs-lisp :noweb yes
(eval-after-load "ox-latex"
  '(progn
     (add-to-list 'org-latex-classes
                  <<org-latex-class-conlang>>)
     (add-to-list 'org-latex-classes
                  <<org-latex-class-beamer>>)))
#+END_SRC

*** Projects
Another great features of Org-mode is the Org projects that allow the user to easily publish a bunch of org files to a remote location. Here is the current declaration of my projects, which will be detailed later:
#+NAME: org-publish-projects
#+BEGIN_SRC emacs-lisp :noweb yes
<<org-proj-config-setup>>
<<org-proj-lang-setup>>
(setq org-publish-project-alist
      `(
        <<org-proj-config-html>>
        <<org-proj-config-static>>
        <<org-proj-config>>
        <<org-proj-lang-html>>
        <<org-proj-lang-pdf>>
        <<org-proj-lang-static>>
        <<org-proj-lang>>))
#+END_SRC

*** Org-ref and Bibtex configuration
#+begin_src emacs-lisp
(use-package reftex
  :commands turn-on-reftex
  :config (setq reftex-default-bibliography "~/Dropbox/Org/bibliography/references.bib"
              reftex-plug-into-AUCTeX     t))
#+end_src

#+begin_src emacs-lisp
(use-package org-ref
  ;; :after (org ox-bibtex pdf-tools)
  :after org
  :defer t
  :straight (:build t)
  :custom-face
  (org-ref-cite-face ((t (:weight bold))))
  :init
  (setq org-ref-completion-library    'org-ref-ivy-cite
        org-latex-logfiles-extensions '("lof" "lot" "aux" "idx" "out" "log" "fbd_latexmk"
                                        "toc" "nav" "snm" "vrb" "dvi" "blg" "brf" "bflsb"
                                        "entoc" "ps" "spl" "bbl" "pygtex" "pygstyle"))
  (add-hook 'org-mode-hook (lambda () (require 'org-ref)))
  :config
  (setq bibtex-completion-pdf-field    "file"
        bibtex-completion-notes-path   "~/Dropbox/Org/bibliography/notes/"
        bibtex-completion-bibliography "~/Dropbox/Org/bibliography/references.bib"
        bibtex-completion-library-path "~/Dropbox/Org/bibliography/bibtex-pdfs/"
        bibtex-completion-pdf-symbol   "⌘"
        bibtex-completion-notes-symbol "✎")
  :general
  (dqv/evil
   :keymaps 'bibtex-mode-map
   :packages 'org-ref
   "C-j" #'org-ref-bibtex-next-entry
   "C-k" #'org-ref-bibtex-previous-entry
   "gj"  #'org-ref-bibtex-next-entry
   "gk"  #'org-ref-bibtex-previous-entry)
  (dqv/major-leader-key
   :keymaps '(bibtex-mode-map)
   :packages 'org-ref
   ;; Navigation
   "j" #'org-ref-bibtex-next-entry
   "k" #'org-ref-bibtex-previous-entry

   ;; Open
   "b" #'org-ref-open-in-browser
   "n" #'org-ref-open-bibtex-notes
   "p" #'org-ref-open-bibtex-pdf

   ;; Misc
   "h" #'org-ref-bibtex-hydra/body
   "i" #'org-ref-bibtex-hydra/org-ref-bibtex-new-entry/body-and-exit
   "s" #'org-ref-sort-bibtex-entry

   "l" '(:ignore t :which-key "lookup")
   "la" #'arxiv-add-bibtex-entry
   "lA" #'arxiv-get-pdf-add-bibtex-entry
   "ld" #'doi-utils-add-bibtex-entry-from-doi
   "li" #'isbn-to-bibtex
   "lp" #'pubmed-insert-bibtex-from-pmid)
  (dqv/major-leader-key
   :keymaps 'org-mode-map
   :pakages 'org-ref
   "ic" #'org-ref-insert-link))
#+end_src

#+begin_src emacs-lisp
(use-package ivy-bibtex
  :defer t
  :straight (:build t)
  :config
  (setq bibtex-completion-pdf-open-function #'find-file)
  :general
  (dqv/leader-key
    :keymaps '(bibtex-mode-map)
    :packages 'ivy-bibtex
    "m" #'ivy-bibtex))
#+end_src

*** TODOs
#+begin_src emacs-lisp
(setq org-return-follows-link t
      org-use-speed-commands t
      org-deadline-warning-days 14
      org-agenda-span 7
      org-agenda-start-on-weekday nil
      org-agenda-tags-column 74)

(setq org-todo-keywords
      '((sequence "TODO(t)" "IDEA(i)" "NEXT(n)" "MUST(m)" "SHOULD(s)" "CLASS(c)" "INPROGRESS(p)" "REVIEW(r)" "|" "DONE(d)" "KILL(k)")
        (sequence "[ ](T)" "[-](S)" "|" "[X](D)")
        (sequence "|" "OKAY(o)" "YES(y)" "NO(n)")))

(defun +log-todo-next-creation-date (&rest ignore)
  "Log NEXT creation time in the property drawer under the key 'ACTIVATED'"
  (when (and (string= (org-get-todo-state) "NEXT")
             (not (org-entry-get nil "ACTIVATED")))
    (org-entry-put nil "ACTIVATED" (format-time-string "[%Y-%m-%d]"))))

(add-hook 'org-after-todo-state-change-hook #'+log-todo-next-creation-date)
#+end_src

*** Tags                                                                  :tag:
#+begin_src emacs-lisp
(setq org-tag-persistent-alist
      '((:startgroup . nil)
        ("home"      . ?h)
        ("research"  . ?r)
        ("work"      . ?w)
        (:endgroup   . nil)
        (:startgroup . nil)
        ("tool"      . ?o)
        ("dev"       . ?d)
        ("report"    . ?p)
        (:endgroup   . nil)
        (:startgroup . nil)
        ("easy"      . ?e)
        ("medium"    . ?m)
        ("hard"      . ?a)
        (:endgroup   . nil)
        ("urgent"    . ?u)
        ("key"       . ?k)
        ("bonus"     . ?b)
        ("ignore"    . ?i)
        ("noexport"  . ?x)))

(setq org-tag-faces
      '(("home"     . (:foreground "goldenrod"  :weight bold))
        ("research" . (:foreground "goldenrod"  :weight bold))
        ("work"     . (:foreground "goldenrod"  :weight bold))
        ("tool"     . (:foreground "IndianRed1" :weight bold))
        ("dev"      . (:foreground "IndianRed1" :weight bold))
        ("report"   . (:foreground "IndianRed1" :weight bold))
        ("urgent"   . (:foreground "red"        :weight bold))
        ("key"      . (:foreground "red"        :weight bold))
        ("easy"     . (:foreground "green4"     :weight bold))
        ("medium"   . (:foreground "orange"     :weight bold))
        ("hard"     . (:foreground "red"        :weight bold))
        ("bonus"    . (:foreground "goldenrod"  :weight bold))
        ("ignore"   . (:foreground "Gray"       :weight bold))
        ("noexport" . (:foreground "LimeGreen"  :weight bold))))
#+end_src

*** Visual Configuration
While most modes of Emacs are dedicated to development, and therefore are much more comfortable with a fixed-pitch font, more literary modes such as org-mode are much more enjoyable if you have a variable pitch font enabled. *BUT*, these modes can also require some fixed-pitch fonts for some elements of the buffer, such as code blocks with org-mode. ~mixed-pitch~ comes to the rescue!
#+begin_src emacs-lisp
(use-package mixed-pitch
  :after org
  :straight (:build t)
  :hook
  (org-mode           . mixed-pitch-mode)
  (emms-browser-mode  . mixed-pitch-mode)
  (emms-playlist-mode . mixed-pitch-mode)
  :config
  (add-hook 'org-agenda-mode-hook (lambda () (mixed-pitch-mode -1))))
#+end_src

I have an issue with org-mode’s emphasis markers: I find them ugly. I can of course hide them if I simply set ~org-hide-emphasis-markers~ to ~t~, but it makes editing hard since I never know whether I am before or after the emphasis marker when editing near the beginning/end of an emphasized region. ~org-appear~ fixes this issue so that it shows the emphasis markers only when the cursor is in the emphasized region, otherwise they will remain hidden! Very cool!
#+begin_src emacs-lisp
(use-package org-appear
  :after org
  :straight (:build t)
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-appear-autoemphasis   t
        org-hide-emphasis-markers t
        org-appear-autolinks      t
        org-appear-autoentities   t
        org-appear-autosubmarkers t)
  (run-at-time nil nil #'org-appear--set-elements))
#+end_src

Similarly, LaTeX fragments previews are nice and all, but if I have my cursor on it, I want to see the LaTeX source code and modify it, not just the generated image!
#+begin_src emacs-lisp
(use-package org-fragtog
  :defer t
  :after org
  :straight (:build t)
  :hook (org-mode . org-fragtog-mode))
#+end_src

Org-modern modernizes a bit the appearance of org buffers, including tables, source blocks, tags, and it applies settings similar to ~org-superstar~ which I used to use.
#+begin_src emacs-lisp
(use-package org-modern
  :straight (:build t)
  :after org
  :defer t
  :hook (org-mode . org-modern-mode)
  :hook (org-agenda-finalize . org-modern-agenda))

(setq org-modern-todo-faces
      '(("TODO" :background "OrangeRed" :foreground "yellow" :weight bold)
        ("MUST" :background "red" :foreground "yellow" :weight bold)
        ("SECTION" :background "#363636" :foreground "white" :weight bold)
        ("DOCUMENT" :background "Yellow" :foreground "white" :weight bold)
        ("SHOULD" :background "Yellow" :foreground "black")
        ("IDEA" :background "Orange" :foreground "black")
        ("INPROGRESS" :background "#1aa7ec" :foreground "black")
        ("REVIEW" :background "#363636" :foreground "yellow" :weight bold)
        ("CLASS" :background "DarkGreen" :foreground "white")
        ("NEXT" :background "#6272a4" :foreground "white")))

(setq org-modern-priority
      (quote ((65 . "❗")
              (66 . "⬆")
              (67 . "⬇"))))

(setq org-modern-priority-faces
      (quote '((65 :background "red" :foreground "yellow")
               (66 :background "orange" :foreground "white")
               (67 :background "DarkGreen" :foreground "black"))))

;; Add frame borders and window dividers
(modify-all-frames-parameters
 '((right-divider-width . 10)
   (internal-border-width . 10)))
(dolist (face '(window-divider
                window-divider-first-pixel
                window-divider-last-pixel))
  (face-spec-reset-face face)
  (set-face-foreground face (face-attribute 'default :background)))
(set-face-background 'fringe (face-attribute 'default :background))

(setq org-modern-label-border 1)

(setq
 ;; Edit settings
 org-auto-align-tags nil
 org-tags-column 0
 org-catch-invisible-edits 'show-and-error
 org-special-ctrl-a/e t
 org-insert-heading-respect-content t

 ;; Org styling, hide markup etc.
 org-hide-emphasis-markers t
 org-pretty-entities t
 org-ellipsis "…"

 ;; Agenda styling
 org-agenda-tags-column 0
 org-agenda-block-separator ?─
 org-agenda-time-grid
 '((daily today require-timed)
   (800 1000 1200 1400 1600 1800 2000)
   " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
 org-agenda-current-time-string

 "⭠ now ─────────────────────────────────────────────────")

(global-org-modern-mode)
#+end_src

*** Misc
~org-tree-slide~ is a presentation tool for org-mode.
#+begin_src emacs-lisp
(use-package org-tree-slide
  :defer t
  :after org
  :straight (:build t)
  :config
  (setq org-tree-slide-skip-done nil)
  :general
  (dqv/major-leader-key
    :keymaps 'org-mode-map
    :packages 'org-mode
    "P" #'org-tree-slide-mode
    "wj" #'org-tree-slide-move-next-tree
    "wk" #'org-tree-slide-move-previous-tree
    "wu" #'org-tree-slide-content))
#+end_src

~org-roll~ is a simple package for tabletop RPGs for rolling dice.
#+begin_src emacs-lisp
(use-package org-roll
  :defer t
  :after org
  :straight (:build t :type git :host github :repo "zaeph/org-roll"))
#+end_src

*** Gcal
#+begin_src emacs-lisp
(setq plstore-cache-passphrase-for-symmetric-encryption t)

(setq org-gcal-client-id "173861024396-9pjbm2u9afoof7f3126rvj66lcin3p5v.apps.googleusercontent.com"
      org-gcal-client-secret "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"
      org-gcal-fetch-file-alist '(("jayden@openedu101.com" .  "~/Dropbox/Org/Personal.org")
                                  ("afcb1caf732361737371b195bc1215ef240e1d905d269bcd08deb2c9a75a091d@group.calendar.google.com" .  "~/Dropbox/Org/Near.org")
                                  ("87dfe7295cad2f0a87b54892de422e657fec4ec38cc8f0c36ea9796525930cb5@group.calendar.google.com" .  "~/Dropbox/Org/Rust.org")
                                  ("693a349513817913e9e6576b6b9dae59668214e00d08f1318c05ece5cdf6d867@group.calendar.google.com" .  "~/Dropbox/Org/Move.org")
                                  ("6daac2cc37c1b859926fd72ccef0595968465a0cce36fa820a2b84ed4428b59d@group.calendar.google.com" .  "~/Dropbox/Org/Work.org")))

(use-package org-gcal
  :straight t
  :config
  (org-gcal-reload-client-id-secret)
  (setq org-gcal-remove-api-cancelled-events t))

#+end_src

+ Customizing the contents of event entries
#+begin_src emacs-lisp
(defun my-org-gcal-set-effort (_calendar-id event _update-mode)
  "Set Effort property based on EVENT if not already set."
  (when-let* ((stime (plist-get (plist-get event :start)
                           :dateTime))
              (etime (plist-get (plist-get event :end)
                                :dateTime))
              (diff (float-time
                     (time-subtract (org-gcal--parse-calendar-time-string etime)
                                    (org-gcal--parse-calendar-time-string stime))))
              (minutes (floor (/ diff 60))))
    (let ((effort (org-entry-get (point) org-effort-property)))
      (unless effort
        (message "need to set effort - minutes %S" minutes)
        (org-entry-put (point)
                       org-effort-property
                       (apply #'format "%d:%02d" (cl-floor minutes 60)))))))
(add-hook 'org-gcal-after-update-entry-functions #'my-org-gcal-set-effort)
#+end_src

*** Roam
#+begin_src emacs-lisp
(use-package org-roam
  :ensure t
  :hook (after-init . org-roam-mode)
  :init
  (setq org-roam-v2-ack t)
  :custom
  (org-roam-directory "~/Dropbox/Roam")
  (org-roam-completion-everywhere t)
  (org-roam-completion-system 'ivy)
  (org-roam-capture-templates
   '(("d" "default" plain
      "%?"
      :if-new (file+head "${slug}.org" "#+TITLE: ${title}\n#+AUTHOR: Dang Quang Vu\n#+EMAIL: jayden@openedu101.com\n#+SETUPFILE: ~/theme-readtheorg.setup\n#+HTML_HEAD: <style>pre.src{background:#343131;color:white;} </style>\n#+EXPORT_FILE_NAME: index.html")
      :unnarrowed t)
     ("l" "programming language" plain
      "* Characteristics\n\n- Family: %?\n- Inspired by: \n\n* Reference:\n\n"
      :if-new (file+head "${slug}.org" "#+TITLE: ${title}\n#+AUTHOR: Dang Quang Vu\n#+EMAIL: jayden@openedu101.com")
      :unnarrowed t)
     ("p" "project" plain "* Goals\n\n%?\n\n* Tasks\n\n** TODO Add initial tasks\n\n* Dates\n\n"
      :if-new (file+head "${slug}.org" "#+TITLE: ${title}\n#+filetags: Project\n#+AUTHOR: Dang Quang Vu\n#+EMAIL: jayden@openedu101.com")
      :unnarrowed t)))
  :config
  (org-roam-setup))
#+end_src


#+begin_src emacs-lisp
(require 'appt)

;; Agenda-to-appointent hooks
(org-agenda-to-appt)             ;; generate the appt list from org agenda files on emacs launch
(run-at-time "24:01" 3600 'org-agenda-to-appt)           ;; update appt list hourly
(add-hook 'org-finalize-agenda-hook 'org-agenda-to-appt) ;; update appt list on agenda view
(appt-activate 1)                ;; activate appointment notification
(setq appt-time-msg-list nil)    ;; clear existing appt list
(setq appt-display-interval '10)  ;; warn every 10 minutes from t - appt-message-warning-time
(setq
  appt-message-warning-time '30  ;; send first warning 15 minutes before appointment
  appt-display-mode-line t     ;; don't show in the modeline
  appt-display-format 'window)   ;; pass warnings to the designated window function


(defun dqv/send-notification (title msg)
  (let ((notifier-path (executable-find "terminal-notifier")))
       (start-process
           "Appointment Alert"
           "*Appointment Alert*" ; use `nil` to not capture output; this captures output in background
           notifier-path
           "-message" msg
           "-title" title
           "-sender" "org.gnu.Emacs"
           "-activate" "org.gnu.Emacs")))

(defun dqv/appt-display-native (min-to-app new-time msg)
  (dqv/send-notification
    (format "Appointment in %s minutes" min-to-app) ; Title
    (format "%s" msg)))                             ; Message/detail text

(setq appt-disp-window-function (function dqv/appt-display-native))
#+end_src

* Packages Configuration
** Autocompletion
*** Code Autocompletion
Company is, in my opinion, the best autocompleting engine for Emacs, and it is one of the most popular if not /the/ most popular.
#+begin_src emacs-lisp
(use-package company
  :straight (:build t)
  :defer t
  :hook (company-mode . evil-normalize-keymaps)
  :init (global-company-mode)
  :config
  (setq company-minimum-prefix-length     2
        company-toolsip-limit             14
        company-idle-delay                0.2
        company-tooltip-align-annotations t
        company-require-match             'never
        company-global-modes              '(not erc-mode message-mode help-mode gud-mode)
        company-frontends
        '(company-pseudo-tooltip-frontend
          company-preview-frontend
          company-echo-metadata-frontend)
        company-backends '(company-capf)
        company-auto-commit         nil
        company-auto-complete-chars nil
        company-dabbrev-other-buffers nil
        company-dabbrev-ignore-case nil
        company-dabbrev-downcase    nil))

(defun company-yasnippet-or-completion ()
  (interactive)
  (or (do-yas-expand)
      (company-complete-common)))

(defun check-expansion ()
  (save-excursion
    (if (looking-at "\\_>") t
      (backward-char 1)
      (if (looking-at "\\.") t
        (backward-char 1)
        (if (looking-at "::") t nil)))))

(defun do-yas-expand ()
  (let ((yas/fallback-behavior 'return-nil))
    (yas/expand)))

(defun tab-indent-or-complete ()
  (interactive)
  (if (minibufferp)
      (minibuffer-complete)
    (if (or (not yas/minor-mode)
            (null (do-yas-expand)))
        (if (check-expansion)
            (company-complete-common)
          (indent-for-tab-command)))))
#+end_src

This package is a backend for company. It emulates ~ac-source-dictionary~ by proposing text related to the current major-mode.
#+begin_src emacs-lisp
(use-package company-dict
  :after company
  :straight (:build t)
  :config
  (setq company-dict-dir (expand-file-name "dicts" user-emacs-directory)))
#+end_src

On the other hand, ~company-box~ is a Company front-end which offers colors, icons, documentation and so on. Very nice.

Declaring all the icons for the variable ~company-box-icons-all-the-icons~ is quite verbose in Elisp, so I do it with an org-table.
#+name: company-box-icons
| Type          | Icon                     | Color  |
|---------------+--------------------------+--------|
| Unknown       | find_in_page             | purple |
| Text          | text_fields              | green  |
| Method        | functions                | red    |
| Function      | functions                | red    |
| Constructor   | functions                | red    |
| Field         | functions                | red    |
| Variable      | adjust                   | blue   |
| Class         | class                    | red    |
| Interface     | settings_input_component | red    |
| Module        | view_module              | red    |
| Property      | settings                 | red    |
| Unit          | straighten               | red    |
| Value         | filter_1                 | red    |
| Enum          | plus_one                 | red    |
| Keyword       | filter_center_focus      | red    |
| Snippet       | short_text               | red    |
| Color         | color_lens               | red    |
| File          | insert_drive_file        | red    |
| Reference     | collections_bookmark     | red    |
| Folder        | folder                   | red    |
| EnumMember    | people                   | red    |
| Constant      | pause_circle_filled      | red    |
| Struct        | streetview               | red    |
| Event         | event                    | red    |
| Operator      | control_point            | red    |
| TypeParameter | class                    | red    |
| Template      | short_text               | green  |
| ElispFunction | functions                | red    |
| ElispVariable | check_circle             | blue   |
| ElispFeature  | stars                    | orange |
| ElispFace     | format_paint             | pink   |

#+name: gen-company-box-icons
#+headers: :tangle no :noweb yes :exports none :cache yes
#+header: :wrap "src emacs-lisp :exports none :tangle no"
#+begin_src emacs-lisp :var table=company-box-icons
(mapconcat (lambda (row)
             (format "(%s . ,(all-the-icons-material \"%s\" :face 'all-the-icons-%s))"
                     (car row)
                     (cadr row)
                     (caddr row)))
           table
           "\n")
#+end_src

#+RESULTS[8ebf4bb3f7f354571a5d42cf58f8b9ba847ba028]: gen-company-box-icons
#+begin_src emacs-lisp :exports none :tangle no
(Unknown . ,(all-the-icons-material "find_in_page" :face 'all-the-icons-purple))
(Text . ,(all-the-icons-material "text_fields" :face 'all-the-icons-green))
(Method . ,(all-the-icons-material "functions" :face 'all-the-icons-red))
(Function . ,(all-the-icons-material "functions" :face 'all-the-icons-red))
(Constructor . ,(all-the-icons-material "functions" :face 'all-the-icons-red))
(Field . ,(all-the-icons-material "functions" :face 'all-the-icons-red))
(Variable . ,(all-the-icons-material "adjust" :face 'all-the-icons-blue))
(Class . ,(all-the-icons-material "class" :face 'all-the-icons-red))
(Interface . ,(all-the-icons-material "settings_input_component" :face 'all-the-icons-red))
(Module . ,(all-the-icons-material "view_module" :face 'all-the-icons-red))
(Property . ,(all-the-icons-material "settings" :face 'all-the-icons-red))
(Unit . ,(all-the-icons-material "straighten" :face 'all-the-icons-red))
(Value . ,(all-the-icons-material "filter_1" :face 'all-the-icons-red))
(Enum . ,(all-the-icons-material "plus_one" :face 'all-the-icons-red))
(Keyword . ,(all-the-icons-material "filter_center_focus" :face 'all-the-icons-red))
(Snippet . ,(all-the-icons-material "short_text" :face 'all-the-icons-red))
(Color . ,(all-the-icons-material "color_lens" :face 'all-the-icons-red))
(File . ,(all-the-icons-material "insert_drive_file" :face 'all-the-icons-red))
(Reference . ,(all-the-icons-material "collections_bookmark" :face 'all-the-icons-red))
(Folder . ,(all-the-icons-material "folder" :face 'all-the-icons-red))
(EnumMember . ,(all-the-icons-material "people" :face 'all-the-icons-red))
(Constant . ,(all-the-icons-material "pause_circle_filled" :face 'all-the-icons-red))
(Struct . ,(all-the-icons-material "streetview" :face 'all-the-icons-red))
(Event . ,(all-the-icons-material "event" :face 'all-the-icons-red))
(Operator . ,(all-the-icons-material "control_point" :face 'all-the-icons-red))
(TypeParameter . ,(all-the-icons-material "class" :face 'all-the-icons-red))
(Template . ,(all-the-icons-material "short_text" :face 'all-the-icons-green))
(ElispFunction . ,(all-the-icons-material "functions" :face 'all-the-icons-red))
(ElispVariable . ,(all-the-icons-material "check_circle" :face 'all-the-icons-blue))
(ElispFeature . ,(all-the-icons-material "stars" :face 'all-the-icons-orange))
(ElispFace . ,(all-the-icons-material "format_paint" :face 'all-the-icons-pink))
#+end_src

#+begin_src emacs-lisp
(use-package company-box
  :straight (:build t)
  :after (company all-the-icons)
  :config
  (setq company-box-show-single-candidate t
        company-box-backends-colors       nil
        company-box-max-candidates        50
        company-box-icons-alist           'company-box-icons-all-the-icons
        company-box-icons-all-the-icons
        (let ((all-the-icons-scale-factor 0.8))
          `(
            <<gen-company-box-icons()>>))))
#+end_src

*** Ivy
My main menu package is ~ivy~ which I use as much as possible –I’ve noticed ~helm~ can be slow, very slow in comparison to ~ivy~ so I’ll use the latter as much as possible. Actually, only ~ivy~ is installed for now. I could have used ~ido~ too, but I find it to be a bit too restricted in terms of features compared to ~ivy~.
#+begin_src emacs-lisp
(use-package ivy
  :straight t
  :defer t
  :diminish
  :bind (("C-s" . swiper)
         :map ivy-minibuffer-map
         ("TAB" . ivy-alt-done)
         ("C-l" . ivy-alt-done)
         ("C-j" . ivy-next-line)
         ("C-k" . ivy-previous-line)
         ("C-u" . ivy-scroll-up-command)
         ("C-d" . ivy-scroll-down-command)
         :map ivy-switch-buffer-map
         ("C-j" . ivy-next-line)
         ("C-k" . ivy-previous-line)
         ("C-l" . ivy-done)
         ("C-d" . ivy-switch-buffer-kill)
         :map ivy-reverse-i-search-map
         ("C-j" . ivy-next-line)
         ("C-k" . ivy-previous-line)
         ("C-d" . ivy-reverse-i-search-kill))
  :config
  (ivy-mode 1)
  (setq ivy-wrap                        t
        ivy-height                      17
        ivy-sort-max-size               50000
        ivy-fixed-height-minibuffer     t
        ivy-read-action-functions       #'ivy-hydra-read-action
        ivy-read-action-format-function #'ivy-read-action-format-columns
        projectile-completion-system    'ivy
        ivy-on-del-error-function       #'ignore
        ivy-use-selectable-prompt       t))
#+end_src

There is also [[https://github.com/raxod502/prescient.el][~prescient.el~]] that offers some nice features when
coupled with ~ivy~, guess what was born out of it? ~ivy-prescient~, of
course!
#+begin_src emacs-lisp
(use-package ivy-prescient
  :after ivy
  :straight (:build t))
#+end_src

I warned you I’d use too much ~all-the-icons~, I did!
#+begin_src emacs-lisp
(use-package all-the-icons-ivy
  :straight (:build t)
  :after (ivy all-the-icons)
  :hook (after-init . all-the-icons-ivy-setup))
#+end_src

A buffer popping at the bottom of the screen is nice and all, but have
you considered a floating buffer in the center of your frame?
#+begin_src emacs-lisp
(use-package ivy-posframe
  :defer t
  :after (:any ivy helpful)
  :hook (ivy-mode . ivy-posframe-mode)
  :straight (:build t)
  :init
  (ivy-posframe-mode 1)
  :config
  (setq ivy-fixed-height-minibuffer nil
        ivy-posframe-border-width   10
        ivy-posframe-parameters
        `((min-width  . 90)
          (min-height . ,ivy-height))))
#+end_src

Finally, let’s make ~ivy~ richer:
#+begin_src emacs-lisp
(use-package ivy-rich
  :straight (:build t)
  :after ivy
  :init
  (ivy-rich-mode 1))
#+end_src

*** Counsel
I could almost merge this chapter with the previous one since counsel is a package that provides loads of completion functions for ivy. The ones I find most useful are ~counsel-M-x~ and ~counsel-find-file~.
#+begin_src emacs-lisp
(use-package counsel
  :straight (:build t)
  :after recentf
  :after ivy
  :bind (("M-x"     . counsel-M-x)
         ("C-x b"   . counsel-ibuffer)
         ("C-x C-f" . counsel-find-file)
         :map minibuffer-local-map
         ("C-r" . 'counsel-minibuffer-history)))
#+end_src

*** Yasnippet
Yasnippet allows you to insert some pre-made code by just typing a few characters. It can even generate some string with Elisp expressions and ask the user for some input in some precise places.
#+begin_src emacs-lisp
(use-package yasnippet
  :defer 15 ;; takes a while to load, so do it async
  :diminish yas-minor-mode
  :straight (:build t)
  :config
  (yas-global-mode)
  :custom
  (yas-prompt-functions '(yas-completing-prompt))
  :hook ((prog-mode . yas-minor-mode)
         (text-mode . yas-minor-mode)))
#+end_src

Of course, yasnippet wouldn’t be as awesome as it is without premade snippets.
#+begin_src emacs-lisp
(use-package yasnippet-snippets
  :defer t
  :after yasnippet
  :straight (:build t))
#+end_src

Similarly, yatemplate offers premade files rather than just strings. That’s still yasnippet by the way.
#+begin_src emacs-lisp
(use-package yatemplate
  :defer t
  :after yasnippet
  :straight (:build t))
#+end_src

And finally, with ivy you can chose your snippets from a menu if you’re not sure or if you don’t remember what your snippet is.
#+begin_src emacs-lisp
(use-package ivy-yasnippet
  :defer t
  :after (ivy yasnippet)
  :straight (:build t)
  :general
  (dqv/leader-key
    :infix "i"
    :packages 'ivy-yasnippet
    "y" #'ivy-yasnippet))
#+end_src

** Applications
*** Docker
Docker is an awesome tool for reproducible development environments. Due to this, I absolutely need a mode for editing Dockerfiles.
#+begin_src emacs-lisp
(use-package dockerfile-mode
  :defer t
  :straight (:build t)
  :hook (dockerfile-mode . lsp-deferred)
  :init
  (put 'docker-image-name 'safe-local-variable #'stringp)
  :mode "Dockerfile\\'")
#+end_src

The ~docker~ package also provides interactivity with Docker and docker-compose from Emacs.
#+begin_src emacs-lisp
(use-package docker
  :defer t
  :straight (:build t))
#+end_src

*** PDF Tools
~pdf-tools~ enables PDF support for Emacs, much better than its built-in support with DocView. Aside from the classical settings such as keybinds, I also enable the midnight colors by default; think of it as an equivalent of Zathura’s recolor feature which kind of enables a dark mode for PDFs.
#+begin_src emacs-lisp
(use-package pdf-tools
  :defer t
  :magic ("%PDF" . pdf-view-mode)
  :straight (:build t)
  :mode (("\\.pdf\\'" . pdf-view-mode))
  :hook (pdf-tools-enabled . pdf-view-midnight-minor-mode)
  :general
  (dqv/evil
    :keymaps 'pdf-view-mode-map
    :packages 'pdf-tools
    "y"   #'pdf-view-kill-ring-save
    "j"   #'evil-collection-pdf-view-next-line-or-next-page
    "k"   #'evil-collection-pdf-view-previous-line-or-previous-page)
  (dqv/major-leader-key
    :keymaps 'pdf-view-mode-map
    :packages 'pdf-tools
    "a"  '(:ignore t :which-key "annotations")
    "aD" #'pdf-annot-delete
    "at" #'pdf-annot-attachment-dired
    "ah" #'pdf-annot-add-highlight-markup-annotation
    "al" #'pdf-annot-list-annotations
    "am" #'pdf-annot-markup-annotation
    "ao" #'pdf-annot-add-strikeout-markup-annotation
    "as" #'pdf-annot-add-squiggly-markup-annotation
    "at" #'pdf-annot-add-text-annotation
    "au" #'pdf-annot-add-underline-markup-annotation

    "f"  '(:ignore t :which-key "fit")
    "fw" #'pdf-view-fit-width-to-window
    "fh" #'pdf-view-fit-height-to-window
    "fp" #'pdf-view-fit-page-to-window

    "s"  '(:ignore t :which-key "slice/search")
    "sb" #'pdf-view-set-slice-from-bounding-box
    "sm" #'pdf-view-set-slice-using-mouse
    "sr" #'pdf-view-reset-slice
    "ss" #'pdf-occur

    "o"  'pdf-outline
    "m"  'pdf-view-midnight-minor-mode)
  :config
  (with-eval-after-load 'pdf-view
    (csetq pdf-view-midnight-colors '("#d8dee9" . "#2e3440"))))
#+end_src

One thing ~pdf-tools~ doesn’t handle is restoring the PDF to the last
point it was visited --- in other words, open the PDF where I last
left it.
#+begin_src emacs-lisp
(use-package pdf-view-restore
  :after pdf-tools
  :defer t
  :straight (:build t)
  :hook (pdf-view-mode . pdf-view-restore-mode)
  :config
  (setq pdf-view-restore-filename (expand-file-name ".tmp/pdf-view-restore"
                                                    user-emacs-directory)))
#+end_src

*** Project Management
**** Magit
***** Magit
Magit is an awesome wrapper around Git for Emacs! Very often, I go from disliking to really hating Git GUI clients because they often obfuscate which Git commands are used to make things happen. Such a thing doesn’t happen with Magit, it’s pretty transparent but it still provides some awesome features and visualizations of what you are doing and what Git is doing! In short, I absolutely love it!
#+begin_src emacs-lisp
(use-package magit
  ;; :diminish magit-auto-revert-mode
  ;; :diminish auto-revert-mode
  :straight (:build t)
  :defer t
  :init
  (setq forge-add-default-bindings nil)
  (setq magit-merge-preview-mode t)
  :config
  (setq magit-diff-options '("-b")) ; ignore whitespace
  (add-to-list 'magit-no-confirm 'stage-all-changes)
  (defadvice magit-insert-unstaged-changes (around sacha activate)
    (if my-magit-limit-to-directory
        (let ((magit-current-diff-range (cons 'index 'working))
              (magit-diff-options (copy-sequence magit-diff-options)))
          (magit-git-insert-section (unstaged "Unstaged changes:")
                                    #'magit-wash-raw-diffs
                                    "diff-files"
                                    "--" my-magit-limit-to-directory))
      ad-do-it))

  (csetq magit-clone-default-directory "~/fromGIT/"
         magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
  (with-eval-after-load 'evil-collection
    (dqv/evil
      :packages '(evil-collection magit)
      :keymaps '(magit-mode-map magit-log-mode-map magit-status-mode-map)
      :states 'normal
      "t" #'magit-tag
      "s" #'magit-stage))
  :general
  (:keymaps '(git-rebase-mode-map)
   :packages 'magit
   "C-j" #'evil-next-line
   "C-k" #'evil-previous-line)
  (dqv/major-leader-key
    :keymaps 'git-rebase-mode-map
    :packages 'magit
    "," #'with-editor-finish
    "k" #'with-editor-cancel
    "a" #'with-editor-cancel)
  (dqv/major-leader-key
    :packages 'magit
    "," #'with-editor-finish
    "k" #'with-editor-cancel
    "a" #'with-editor-cancel)
  (dqv/leader-key
    :infix   "g"
    :packages 'magit
    ""   '(:ignore t :which-key "git")
    "b"  #'magit-blame
    "c"  #'magit-clone
    "d"  #'magit-dispatch
    "i"  #'magit-init
    "s"  #'magit-status
    "y"  #'my/yadm
    "S"  #'magit-stage-file
    "U"  #'magit-unstage-file
    "f"  '(:ignore t :which-key "file")
    "fd" #'magit-diff
    "fc" #'magit-file-checkout
    "fl" #'magit-file-dispatch
    "fF" #'magit-find-file))
#+end_src

***** HL Todo
[[https://github.com/alphapapa][Alphapapa]] also created an awesome package for Magit: magit-todos which display in the Magit buffer a list of TODOs found in the current project to remind you of what to do next.

First, let’s setup our todo keywords with ~hl-todo~. A good few todo keywords are already defined in the ~hl-todo-keyword-faces~ variable. Why not use them? ~hl-todo-mode~ enables fontlock highlight of these keywords in a buffer. Let’s enable this mode globally.
#+begin_src emacs-lisp
(use-package hl-todo
  :defer t
  :straight (:build t)
  :init (global-hl-todo-mode 1)
  :general
  (dqv/leader-key
    :packages '(hl-todo)
    :infix "c"
    ""  '(:ignore t :which-key "todos")
    "n" #'hl-todo-next
    "p" #'hl-todo-previous))
#+end_src

***** Magit Todos
We can now configure properly ~magit-todos~. Notice my custom function hooked to ~magit-mode-hook~. This is because this package tries to find TODOs in all files in the current project, and my yadm repository’s root is my ~$HOME~. So, yeah, no ~magit-todos~ in yadm.
#+begin_src emacs-lisp
(use-package magit-todos
  :defer t
  :straight (:build t)
  :after (magit hl-todo)
  :init
  (with-eval-after-load 'magit
   (defun my/magit-todos-if-not-yadm ()
     "Deactivate magit-todos if in yadm Tramp connection.
If `magit--default-directory' points to a yadm Tramp directory,
deactivate `magit-todos-mode', otherwise enable it."
     (if (string-prefix-p "/yadm:" magit--default-directory)
         (magit-todos-mode -1)
       (magit-todos-mode +1)))
   (add-hook 'magit-mode-hook #'my/magit-todos-if-not-yadm))
  :config
  (csetq magit-todos-ignore-case t)
(setq magit-todos-keyword-suffix "\\(?:([^)]+)\\)?:"))
#+end_src

***** Gitflow
Finally, it is also possible to use Gitflow’s framework with Magit with ~magit-gitflow~:
#+begin_src emacs-lisp
(use-package magit-gitflow
  :defer t
  :after magit
  :straight (magit-gitflow :build t
                           :type git
                           :host github
                           :repo "jtatarik/magit-gitflow")
  :hook (magit-mode . turn-on-magit-gitflow))
#+end_src

***** Forge
Forge acts as an interface for Github, Gitlab, and Bitbucket inside Magit. A lot of possibilities are present, you can read issues and pull requests, create them, and fork projects among other things.
*NOTE*: Make sure to configure a GitHub token before using this package!
- [[https://magit.vc/manual/forge/Token-Creation.html#Token-Creation][Token Creation]]
- [[https://magit.vc/manual/ghub/Getting-Started.html#Getting-Started][Getting started]]
#+begin_src emacs-lisp
(use-package forge
  :ensure t
  :after magit
  :straight (:build t)
  :config
  :general
  (dqv/major-leader-key
    :keymaps 'forge-topic-mode-map
    "c"  #'forge-create-post
    "e"  '(:ignore t :which-key "edit")
    "ea" #'forge-edit-topic-assignees
    "ed" #'forge-edit-topic-draft
    "ek" #'forge-delete-comment
    "el" #'forge-edit-topic-labels
    "em" #'forge-edit-topic-marks
    "eM" #'forge-merge
    "en" #'forge-edit-topic-note
    "ep" #'forge-edit-post
    "er" #'forge-edit-topic-review-requests
    "es" #'forge-edit-topic-state
    "et" #'forge-edit-topic-title))
#+end_src

***** Code Review
#+begin_src emacs-lisp
(use-package code-review
  :after magit
  :bind (:map forge-topic-mode-map ("C-c r" . #'code-review-forge-pr-at-point))
  :bind (:map code-review-mode-map (("C-c n" . #'code-review-comment-jump-next)
                                    ("C-c p" . #'code-review-comment-jump-previous))))
#+end_src

***** Git message
#+begin_src emacs-lisp
(use-package git-messenger
  :straight (:build t)
  :bind (("C-x v m" . git-messenger:popup-message)))
#+end_src

***** Add Issue Number To Commit Message
#+begin_src emacs-lisp
 (defun buffer-insert-at-end (string)
    "Insert STRING at the maximal point in a buffer."
    (save-excursion
      (goto-char (point-max))
      (end-of-line)
      (insert ?\n string)
      (unless (string-suffix-p "\n" string)
        (insert ?\n))))

  (defun get-knuth-number-from-string (string)
    "Return KNUTH issue number from STRING.
  Return nil if STRING does not contain a KNUTH issue.
  STRING may be nil."
    (if (and string (string-match "\\(KNUTH-[[:digit:]]\+\\)" string))
        (match-string 1 string)
      nil))

  (defun insert-knuth-ticket-number-from-branch ()
    "If we're on a KNUTH feature branch, insert the ticket number."
    (interactive)
    (let ((knuth (get-knuth-number-from-string (magit-get-current-branch))))
      (if (and knuth (not (buffer-line-matches-p (concat "^" knuth)))) (buffer-insert-at-end knuth))))

  (defun buffer-line-matches-p (needle)
    "Return t if the last line matches NEEDLE.
  Ignores comments"
    (save-excursion
      (goto-char 0)
      (search-forward-regexp needle nil 'noerror)))

  (add-hook 'git-commit-setup-hook 'insert-knuth-ticket-number-from-branch)
#+end_src

***** Magit Gh
#+begin_src emacs-lisp
(defun my-magit-stage-all-and-commit (message)
  (interactive (list (progn (magit-diff-unstaged) (read-string "Commit Message: "))))
  (magit-stage-modified)
  (magit-commit-create (list "-m" message))
  (call-interactively #'magit-push-current-to-pushremote))
(defvar my-magit-limit-to-directory nil "Limit magit status to a specific directory.")
(defun my-magit-status-in-directory (directory)
  "Displays magit status limited to DIRECTORY.
 Uses the current `default-directory', or prompts for a directory
 if called with a prefix argument. Sets `my-magit-limit-to-directory'
 so that it's still active even after you stage a change. Very experimental."
  (interactive (list (expand-file-name
                        (if current-prefix-arg
                            (read-directory-name "Directory: ")
                          default-directory))))
  (setq my-magit-limit-to-directory directory)
  (magit-status directory))
#+end_src

**** Projectile
First, I need to install ~ripgrep~, a faster reimplementation of ~grep~, which will be very useful when managing projects.
#+begin_src emacs-lisp
(use-package ripgrep
  :if (executable-find "rg")
  :straight (:build t)
  :defer t)
#+end_src

Now, I can use projectile, which is sort of the /de facto/ standard
project manager in Emacs. I know there’s ~project.el~, but,… Eh…
#+begin_src emacs-lisp
(use-package projectile
  :straight (:build t)
  :diminish projectile-mode
  :custom ((projectile-completion-system 'ivy))
  :init
  (setq projectile-switch-project-action #'projectile-dired)
  :config
  (projectile-mode)
  (add-to-list 'projectile-ignored-projects "~/")
  (add-to-list 'projectile-globally-ignored-directories "^node_modules$")
  :general
  (dqv/leader-key
    "p" '(:keymap projectile-command-map :which-key "projectile")))
#+end_src

And of course, there is a counsel package dedicated to projectile.
#+begin_src emacs-lisp
(use-package counsel-projectile
  :straight (:build t)
  :after (counsel projectile)
  :config (counsel-projectile-mode))
#+end_src

**** Recentf
The built-in package ~recentf~ keeps track of recently opened files. But by default, it only follows the twenty most recent files, that not nearly enough for me, so I raise it to two hundred. I also don’t want recentf to follow the Elfeed database, so I add it to the list of excluded files.
#+begin_src emacs-lisp
(use-package recentf
  :straight (:build t :type built-in)
  :custom ((recentf-max-saved-items 2000))
  :config
  ;; no Elfeed or native-comp files
  (add-all-to-list 'recentf-exclude
                   `(,(rx (* any)
                          (or "elfeed-db"
                              "eln-cache"
                              "conlanging/content"
                              "org/config"
                              "/Mail/Sent"
                              ".cache/")
                          (* any)
                          (? (or "html" "pdf" "tex" "epub")))
                     ,(rx "/"
                          (or "rsync" "ssh" "tmp" "yadm" "sudoedit" "sudo")
                          (* any)))))
#+end_src

*** Shells
**** Shell-pop
Shell-pop allows the user to easily call for a new shell in a pop-up buffer.
#+begin_src emacs-lisp
(use-package shell-pop
  :defer t
  :straight (:build t)
  :custom
  (shell-pop-default-directory "/Users/dangeamon")
  (shell-pop-shell-type (quote ("eshell" "*eshell*" (lambda () (eshell shell-pop-term-shell)))))
  (shell-pop-window-size 30)
  (shell-pop-full-span nil)
  (shell-pop-window-position "bottom")
  (shell-pop-autocd-to-working-dir t)
  (shell-pop-restore-window-configuration t)
  (shell-pop-cleanup-buffer-at-process-exit t))
#+end_src

**** VTerm
- Gives Emacs access to regular shells with an almost regular emulator. Be aware you will most likely need to hit ~C-c~ twice to send an interrupt signal.
#+begin_src emacs-lisp
(use-package popwin
  :straight t)

(with-eval-after-load 'popwin
  (dqv/leader-key
    "oe" '(+popwin:eshell :which-key "Eshell popup")
    "oE" '(eshell :which-key "Eshell"))
  (defun +popwin:eshell ()
    (interactive)
    (popwin:display-buffer-1
     (or (get-buffer "*eshell*")
         (save-window-excursion
           (call-interactively 'eshell)))
     :default-config-keywords '(:position :bottom :height 14))))

(use-package vterm
  :defer t
  :straight t
  :general
  (dqv/leader-key
   "ot" '(+popwin:vterm :which-key "vTerm popup")
   "oT" '(vterm :which-key "vTerm"))
  :preface
  (when noninteractive
    (advice-add #'vterm-module-compile :override #'ignore)
    (provide 'vterm-module))
  :custom
  (vterm-max-scrollback 5000)
  :config
  (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")  ;; Set this to match your custom shell prompt
  (setq vterm-shell "zsh")                       ;; Set this to customize the shell to launch
  (setq vterm-max-scrollback 10000)
  (with-eval-after-load 'popwin
    (defun +popwin:vterm ()
      (interactive)
      (popwin:display-buffer-1
       (or (get-buffer "*vterm*")
           (save-window-excursion
             (call-interactively 'vterm)))
       :default-config-keywords '(:position :bottom :height 14)))))
#+end_src

One annoying think with vterm is it only can create one buffer, you can’t have multiple vterm buffers by default. ~multi-vterm~ fixes this issue.
#+begin_src emacs-lisp
(use-package multi-vterm
  :after vterm
  :defer t
  :straight (:build t)
  :general
  (dqv/major-leader-key
    :packages '(vterm multi-vterm)
    :keymap 'vterm-mode-map
    "c" #'multi-vterm
    "j" #'multi-vterm-next
    "k" #'multi-vterm-prev))
#+end_src

*** Leetcode
#+begin_src emacs-lisp
(use-package leetcode
  :ensure t
  :straight (:build t))
(setq leetcode-prefer-language "rust"
      leetcode-prefer-sql "mysql"
      leetcode-save-solutions t
      leetcode-directory "~/Development/leetcode-solution")
#+end_src

** Editing
*** Editorconfig
Editorconfig is a unified way of passing to your text editor settings everyone working in a repo need to follow. ~.editorconfig~ files work for VSCode users, vim users, Atom users, Sublime users, and of course Emacs users.
#+begin_src emacs-lisp
(use-package editorconfig
  :defer t
  :straight (:build t)
  :diminish editorconfig-mode
  :config
  (editorconfig-mode t))
#+end_src

*** Evil Nerd Commenter
Emacs’ default commenting system is nice, but I don’t find it smart enough for me.
#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :after evil
  :straight (:build t))
(global-set-key (kbd "s-/") #'evilnc-comment-or-uncomment-lines)
#+end_src

*** Iedit
Iedit is a powerful text editing tool that can be used to refactor code through the edition of multiple regions at once, be it in a region or in a whole buffer. Since I’m using evil, I’ll also use a compatibility package that adds states for iedit.
#+begin_src emacs-lisp
(use-package evil-iedit-state
  :defer t
  :straight (:build t)
  :commands (evil-iedit-state evil-iedit-state/iedit-mode)
  :init
  (setq iedit-curent-symbol-default     t
        iedit-only-at-symbol-boundaries t
        iedit-toggle-key-default        nil)
  :general
  (dqv/leader-key
    :infix "r"
    :packages '(iedit evil-iedit-state)
    "" '(:ignore t :which-key "refactor")
    "i" #'evil-iedit-state/iedit-mode)
  (general-define-key
   :keymaps 'evil-iedit-state-map
   "c" nil
   "s" nil
   "J" nil
   "S" #'iedit-expand-down-a-line
   "T" #'iedit-expand-up-a-line
   "h" #'evil-iedit-state/evil-change
   "k" #'evil-iedit-state/evil-substitute
   "K" #'evil-iedit-state/substitute
   "q" #'evil-iedit-state/quit-iedit-mode))
#+end_src

*** Smartparens
~smartparens~ is a package similar to ~parinfer~, but while the latter is more specialized for Lisp dialects, ~smartparens~ works better with other programming languages that still uses parenthesis, but not as much as Lisp dialects; think for example C, C++, Rust, Javascript, and so on.
#+begin_src emacs-lisp
(add-to-list 'load-path "~/.emacs.d/lisp/smartparens")
(use-package smartparens
  :defer t
  ;; :straight (:build t)
  :hook (prog-mode . smartparens-mode))
#+end_src

*** WebAssembly Mode
#+begin_src emacs-lisp
(add-to-list 'load-path "~/.emacs.d/lisp/wat-mode/")
(require 'wat-mode)
#+end_src

*** Parinfer
Don’t let the name of the package fool you! ~parinfer-rust-mode~ is not a ~parinfer~ mode for ~rust-mode~, but a mode for ~parinfer-rust~. ~parinfer~ was a project for handling parenthesis and other double markers in a much more intuitive way when writing Lisp code. However, it is now out of date (last commit was on January 2nd, 2019) and the repository has since been archived. New implementations then appeared, one of them is [[https://github.com/eraserhd/parinfer-rust][~parinfer-rust~]], obviously written in Rust, around which ~parinfer-rust-mode~ is built. Enabling ~parinfer-rust-mode~ should also automatically disable ~smartparens-mode~ in order to avoid conflicting behavior.
#+begin_src emacs-lisp
(use-package parinfer-rust-mode
  :defer t
  :straight (:build t)
  :diminish parinfer-rust-mode
  :hook emacs-lisp-mode common-lisp-mode scheme-mode
  :init
  (setq parinfer-rust-auto-download     t
        parinfer-rust-library-directory (concat user-emacs-directory
                                                "parinfer-rust/"))
  (add-hook 'parinfer-rust-mode-hook
            (lambda () (smartparens-mode -1)))
  :general
  (dqv/major-leader-key
    :keymaps 'parinfer-rust-mode-map
    "m" #'parinfer-rust-switch-mode
    "M" #'parinfer-rust-toggle-disable))
#+end_src

*** Maple-iedit
#+begin_src emacs-lisp
(use-package maple-iedit
  :ensure nil
  :commands (maple-iedit-match-all maple-iedit-match-next maple-iedit-match-previous)
  :config
  (setq maple-iedit-ignore-case t)

  (defhydra maple/iedit ()
    ("n" maple-iedit-match-next "next")
    ("t" maple-iedit-skip-and-match-next "skip and next")
    ("T" maple-iedit-skip-and-match-previous "skip and previous")
    ("p" maple-iedit-match-previous "prev"))
  :bind (:map evil-visual-state-map
              ("n" . maple/iedit/body)
              ;; ("C-n" . maple-iedit-match-next)
              ;; ("C-p" . maple-iedit-match-previous)
              ("C-t" . maple-iedit-skip-and-match-next)))
#+end_src

*** Engine
#+begin_src emacs-lisp
  (use-package engine-mode
    :config
    (engine/set-keymap-prefix (kbd "C-c s"))
    (setq browse-url-browser-function 'browse-url-default-macosx-browser
          engine/browser-function 'browse-url-default-macosx-browser)

    (defengine duckduckgo
      "https://duckduckgo.com/?q=%s"
      :keybinding "d")

    (defengine github
      "https://github.com/search?ref=simplesearch&q=%s"
      :keybinding "1")

    (defengine npm
      "https://www.npmjs.com/search?q=%s"
      :keybinding "n")

    (defengine crates
      "https://crates.io/search?q=%s"
      :keybinding "c")

    (defengine localhost
      "http://localhost:%s"
      :keybinding "l")

    (defengine vocabulary
      "https://www.vocabulary.com/dictionary/%s"
      :keybinding "t")

    (defengine translate
      "https://translate.google.com/?hl=vi&sl=en&tl=vi&text=%s&op=translate"
      :keybinding "T")

    (defengine youtube
      "http://www.youtube.com/results?aq=f&oq=&search_query=%s"
      :keybinding "y")

    (defengine google
      "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s"
      :keybinding "g")

    (defengine sui-localnet
      "https://suiexplorer.com/txblock/%s?network=local"
      :keybinding "s l")

    (defengine sui-devnnet
      "https://suiexplorer.com/txblock/%s?network=devnet"
      :keybinding "s d")

    (defengine sui-mainnet
      "https://suiexplorer.com/txblock/%s?network=mainnet"
      :keybinding "s m")

    (engine-mode 1))
#+end_src

*** Bm
#+begin_src emacs-lisp
  (use-package bm
    :demand t
    :init
    ;; restore on load (even before you require bm)
    (setq bm-restore-repository-on-load t)

    :config
    ;; Allow cross-buffer 'next'
    (setq bm-cycle-all-buffers t

          ;; where to store persistant files
          bm-repository-file "~/.emacs.d/bm-repository")

    ;; save bookmarks
    (setq-default bm-buffer-persistence t)

    ;; Loading the repository from file when on start up.
    (add-hook 'after-init-hook 'bm-repository-load)

    ;; Saving bookmarks
    (add-hook 'kill-buffer-hook #'bm-buffer-save)

    ;; must save all bookmarks first.
    (add-hook 'kill-emacs-hook #'(lambda nil
                                   (bm-buffer-save-all)
                                   (bm-repository-save)))

    (add-hook 'after-save-hook #'bm-buffer-save)

    ;; Restoring bookmarks
    (add-hook 'find-file-hooks   #'bm-buffer-restore)
    (add-hook 'after-revert-hook #'bm-buffer-restore)

    (add-hook 'vc-before-checkin-hook #'bm-buffer-save)

    ;; keys binding
    :bind (("C-M-s-x" . bm-toggle)
           ("C-M-s-w" . bm-lifo-next)
           ("C-M-s-q" . bm-lifo-previous)
           ("C-M-s-z" . bm-show-all))
    )
#+end_src

*** Move Text
#+begin_src emacs-lisp
(use-package move-text
  :straight (:build t))

(global-set-key (kbd "s-j") #'move-text-down)
(global-set-key (kbd "s-k") #'move-text-up)
#+end_src

*** Hide-show
#+begin_src emacs-lisp
(use-package hideshow
  :hook
  (prog-mode . hs-minor-mode)
  :bind
  ("C-<tab>" . hs-cycle)
  ("C-<iso-lefttab>" . hs-global-cycle)
  ("C-S-<tab>" . hs-global-cycle))
(defun hs-cycle (&optional level)
  (interactive "p")
  (let (message-log-max
        (inhibit-message t))
    (if (= level 1)
        (pcase last-command
          ('hs-cycle
           (hs-hide-level 1)
           (setq this-command 'hs-cycle-children))
          ('hs-cycle-children
           ;; called twice to open all folds of the parent
           ;; block.
           (save-excursion (hs-show-block))
           (hs-show-block)
           (setq this-command 'hs-cycle-subtree))
          ('hs-cycle-subtree
           (hs-hide-block))
          (_
               (hs-hide-block)
             (hs-hide-level 1)
             (setq this-command 'hs-cycle-children)))
      (hs-hide-level level)
      (setq this-command 'hs-hide-level))))

(defun hs-global-cycle ()
    (interactive)
    (pcase last-command
      ('hs-global-cycle
       (save-excursion (hs-show-all))
       (setq this-command 'hs-global-show))
      (_ (hs-hide-all))))
#+end_src

*** Eyebrown
#+begin_src emacs-lisp
  (use-package eyebrowse
    :straight (:build t)
    :config
    (setq eyebrowse-new-workspace t)
    (eyebrowse-mode 1))

  (dqv/leader-key
   "TAB"  '(:ignore t :which-key "Window Management")
   "TAB 0" '(eyebrowse-switch-to-window-config-0 :which-key "Select Windown 0")
   "TAB 1" '(eyebrowse-switch-to-window-config-1 :which-key "Select Window 1")
   "TAB 2" '(eyebrowse-switch-to-window-config-2 :which-key "Select Window 2")
   "TAB 3" '(eyebrowse-switch-to-window-config-3 :which-key "Select Window 3")
   "TAB 4" '(eyebrowse-switch-to-window-config-4 :which-key "Select Window 4")
   "TAB 5" '(eyebrowse-switch-to-window-config-5 :which-key "Select Window 5")
   "TAB 6" '(eyebrowse-switch-to-window-config-6 :which-key "Select Window 6")
   "TAB 7" '(eyebrowse-switch-to-window-config-7 :which-key "Select Window 7")
   "TAB 8" '(eyebrowse-switch-to-window-config-8 :which-key "Select Window 8")
   "TAB 9" '(eyebrowse-switch-to-window-config-9 :which-key "Select Window 9")
   "TAB r" '(eyebrowse-rename-window-config :which-key "Rename Window")
   "TAB n" '(eyebrowse-create-named-window-config :which-key "Create New Window")
   "TAB TAB" '(eyebrowse-switch-to-window-config :which-key "Switch Window")
   "TAB d" '(eyebrowse-close-window-config :which-key "Delete Window")
   "TAB k" '(eyebrowse-next-window-config :which-key "Next Window")
   "TAB j" '(eyebrowse-prev-window-config :which-key "Previous Window"))
#+end_src

** Emacs built-ins
*** Dired
Dired is Emacs’ built-in file manager. It’s really great, and replaces any graphical file manager for me most of the time because:
- I am not limited to /x/ tabs or panes
- All actions can be done with keybindings
- I get a consistent behavior between Dired and Emacs, since it’s the same thing.
I used to have an extensive configuration for Dired with a couple of additional packages to make it more usable. Dirvish rendered that obsolete!
#+begin_src emacs-lisp
(use-package dirvish
  :straight (:build t)
  :defer t
  :init (dirvish-override-dired-mode)
  :custom
  (dirvish-quick-access-entries
   '(("h" "~/" "Home")
     ("d" "~/Downloads/" "Downloads")
     ("b" "~/Bootcamp/" "Bootcamp")
     ("r" "~/Dropbox/Roam/" "Roam")
     ("D" "~/Develop/" "Develop")
     ("C" "~/Documents/conlanging/content" "Conlanging")))
  (dirvish-mode-line-format
   '(:left (sort file-time " " file-size symlink) :right (omit yank index)))
   (dirvish-attributes '(all-the-icons file-size  subtree-state vc-state  collapse )) ;; git-msg file-time
  (setq delete-by-moving-to-trash t)
  :config
  (dirvish-peek-mode)
  <<dired-drag-and-drop>>
  <<dired-listing-flags>>
  <<dired-files-and-dirs>>
  <<dirvish-exa-offload>>
  (csetq dired-dwim-target         t
         dired-recursive-copies    'always
         dired-recursive-deletes   'top
         delete-by-moving-to-trash t)
  :general
  (dqv/evil
    :keymaps 'dirvish-mode-map
    :packages '(dired dirvish)
    "q" #'dirvish-quit
    "TAB" #'dirvish-subtree-toggle)
  (dqv/major-leader-key
    :keymaps 'dirvish-mode-map
    :packages '(dired dirvish)
    "A"   #'gnus-dired-attach
    "a"   #'dirvish-quick-access
    "d"   #'dirvish-dispatch
    "e"   #'dirvish-emerge-menu
    "f"   #'dirvish-fd-jump
    "F"   #'dirvish-file-info-menu
    "h"   '(:ignore t :which-key "history")
    "hp"  #'dirvish-history-go-backward
    "hn"  #'dirvish-history-go-forward
    "hj"  #'dirvish-history-jump
    "hl"  #'dirvish-history-last
    "l"   '(:ignore t :which-key "layout")
    "ls"  #'dirvish-layout-switch
    "lt"  #'dirvish-layout-toggle
    "m"   #'dirvish-mark-menu
    "s"   #'dirvish-quicksort
    "S"   #'dirvish-setup-menu
    "y"   #'dirvish-yank-menu
    "n"   #'dirvish-narrow))
#+end_src

Since Emacs 29, it is possible to enable drag-and-drop between Emacs and other applications.
#+name: dired-drag-and-drop
#+begin_src emacs-lisp :tangle no
(csetq dired-mouse-drag-files                   t
       mouse-drag-and-drop-region-cross-program t)

(setq-default truncate-lines t)
#+end_src

In Dirvish, it’s best to use the long name of flags whenever possible, otherwise some commands won’t work.
#+name: dired-listing-flags
#+begin_src emacs-lisp :tangle no
(csetq dired-listing-switches (string-join '("--all"
                                             "--human-readable"
                                             "--time-style=long-iso"
                                             "--group-directories-first"
                                             "-lv1")
                                           " "))
#+end_src

However, it is possible to instead use ~exa~ when it is available. Instead of making Emacs’ main thread to the file listing in a directory, we offload it to an external thread.
#+name: dirvish-exa-offload
#+begin_src emacs-lisp :tangle no
(dirvish-define-preview exa (file)
  "Use `exa' to generate directory preview."
  :require ("exa")
  (when (file-directory-p file)
    `(shell . ("exa"  "-al" "--color=always" "--icons" "--group-directories-first" ,file))))

(set-face-attribute 'ansi-color-blue nil :foreground "#FFFFFF")
(add-to-list 'dirvish-preview-dispatchers 'exa)
#+end_src

Finally, some directories need to be set for Dired to store various
files and images.
#+name: dired-files-and-dirs
#+begin_src emacs-lisp :tangle no
(let ((my/file (lambda (path &optional dir)
                 (expand-file-name path (or dir user-emacs-directory))))
      (my/dir (lambda (path &optional dir)
                (expand-file-name (file-name-as-directory path)
                                  (or dir user-emacs-directory)))))
  (csetq image-dired-thumb-size             150
         image-dired-dir                    (funcall my/dir "dired-img")
         image-dired-db-file                (funcall my/file "dired-db.el")
         image-dired-gallery-dir            (funcall my/dir "gallery")
         image-dired-temp-image-file        (funcall my/file "temp-image" image-dired-dir)
         image-dired-temp-rotate-image-file (funcall my/file "temp-rotate-image" image-dired-dir)))
#+end_src

Copying files with Dired is a blocking process. It’s usually fine when there’s not a lot to copy, but it becomes more annoying when moving larger files. The package ~dired-rsync~ allows to copy files with ~rsync~ in the background so we can carry on with our tasks while the copy is happening.
#+begin_src emacs-lisp
(use-package dired-rsync
  :if (executable-find "rsync")
  :defer t
  :straight (:build t)
  :general
  (dqv/evil
    :keymaps 'dired-mode-map
    :packages 'dired-rsync
    "C-r" #'dired-rsync))
#+end_src

*** Image-mode
I won’t modify much for ~image-mode~ (the mode used to display images) aside from Emacs’ ability to use external converters to display some images it wouldn’t be able to handle otherwise.
#+begin_src emacs-lisp
(setq image-use-external-converter t)
#+end_src

** Making my life easier
*** Bufler
+ Bufler is an excellent package by alphapapa which enables you to automatically group all of your Emacs buffers into workspaces by defining a series of grouping rules. Once you have your groups defined (or use the default configuration which is quite good already), you can use the bufler-workspace-frame-set command to focus your current Emacs frame on a particular workspace so that bufler-switch-buffer will only show buffers from that workspace. In my case, this allows me to dedicate an EXWM workspace to a specific Bufler workspace so that only see the buffers I care about in that EXWM workspace.
#+begin_src emacs-lisp
(use-package bufler
  :straight (:build t)
  :bind (("C-M-j" . bufler-switch-buffer)
         ("C-M-k" . bufler-workspace-frame-set))
  :config
  (evil-collection-define-key 'normal 'bufler-list-mode-map
    (kbd "RET")   'bufler-list-buffer-switch
    (kbd "M-RET") 'bufler-list-buffer-peek
    "D"           'bufler-list-buffer-kill)

  (setf bufler-groups
        (bufler-defgroups
          ;; Subgroup collecting all named workspaces.
          (group (auto-workspace))
          ;; Subgroup collecting buffers in a projectile project.
          (group (auto-projectile))
          ;; Grouping browser windows
          (group
           (group-or "Browsers"
                     (name-match "Vimb" (rx bos "vimb"))
                     (name-match "Qutebrowser" (rx bos "Qutebrowser"))
                     (name-match "Chromium" (rx bos "Chromium"))))
          (group
           (group-or "Chat"
                     (mode-match "Telega" (rx bos "telega-"))))
          (group
           ;; Subgroup collecting all `help-mode' and `info-mode' buffers.
           (group-or "Help/Info"
                     (mode-match "*Help*" (rx bos (or "help-" "helpful-")))
                     ;; (mode-match "*Helpful*" (rx bos "helpful-"))
                     (mode-match "*Info*" (rx bos "info-"))))
          (group
           ;; Subgroup collecting all special buffers (i.e. ones that are not
           ;; file-backed), except `magit-status-mode' buffers (which are allowed to fall
           ;; through to other groups, so they end up grouped with their project buffers).
           (group-and "*Special*"
                      (name-match "**Special**"
                                  (rx bos "*" (or "Messages" "Warnings" "scratch" "Backtrace" "Pinentry") "*"))
                      (lambda (buffer)
                        (unless (or (funcall (mode-match "Magit" (rx bos "magit-status"))
                                             buffer)
                                    (funcall (mode-match "Dired" (rx bos "dired"))
                                             buffer)
                                    (funcall (auto-file) buffer))
                          "*Special*"))))
          ;; Group remaining buffers by major mode.
          (auto-mode))))
#+end_src

*** Helpful
As the name tells, ~helpful~ is a really helpful package which greatly enhances a couple of built-in functions from Emacs, namely:
| Vanilla Emacs Function | Helpful Function | Comment                                       |
|------------------------+------------------+-----------------------------------------------|
| ~describe-function~      | ~helpful-callable~ | Only interactive functions                    |
| ~describe-function~      | ~helpful-function~ | Only actual functions (including interactive) |
| ~describe-function~      | ~helpful-macro~    |                                               |
| ~describe-command~       | ~helpful-command~  |                                               |
| ~describe-key~           | ~helpful-key~      |                                               |
| ~describe-variable~      | ~helpful-variable~ |                                               |

#+begin_src emacs-lisp
(use-package helpful
  :straight (:build t)
  :after (counsel ivy)
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  :bind
  ([remap describe-function] . counsel-describe-function)
  ([remap describe-command]  . helpful-command)
  ([remap describe-variable] . counsel-describe-variable)
  ([remap describe-key]      . helpful-key))
#+end_src

** LaTeX
#+begin_src emacs-lisp :noweb yes
(use-package auctex
  :defer t
  :straight (:build t)
  :hook (tex-mode . lsp-deferred)
  :hook (latex-mode . lsp-deferred)
  :init
  (setq TeX-command-default   (if (executable-find "latexmk") "LatexMk" "LaTeX")
        TeX-engine            (if (executable-find "xetex")   'xetex    'default)
        TeX-auto-save                     t
        TeX-parse-self                    t
        TeX-syntactic-comment             t
        TeX-auto-local                    ".auctex-auto"
        TeX-style-local                   ".auctex-style"
        TeX-source-correlate-mode         t
        TeX-source-correlate-method       'synctex
        TeX-source-correlate-start-server nil
        TeX-electric-sub-and-superscript  t
        TeX-fill-break-at-separators      nil
        TeX-save-query                    t)
  :config
  <<latex-fontification>>
  (setq TeX-master t)
  (setcar (cdr (assoc "Check" TeX-command-list)) "chktex -v6 -H %s")
  (add-hook 'TeX-mode-hook (lambda ()
                             (setq ispell-parser          'tex
                                   fill-nobreak-predicate (cons #'texmathp fill-nobreak-predicate))))
  (add-hook 'TeX-mode-hook #'visual-line-mode)
  (add-hook 'TeX-update-style-hook #'rainbow-delimiters-mode)
  :general
  (dqv/major-leader-key
    :packages 'auctex
    :keymaps  '(latex-mode-map LaTeX-mode-map)
    "v" '(TeX-view            :which-key "View")
    "c" '(TeX-command-run-all :which-key "Compile")
    "m" '(TeX-command-master  :which-key "Run a command")))
#+end_src

From Doom Emacs’ configuration:
#+name: latex-fontification
#+begin_src emacs-lisp :tangle no
(setq font-latex-match-reference-keywords
      '(;; BibLaTeX.
        ("printbibliography" "[{") ("addbibresource" "[{")
        ;; Standard commands.
        ("cite" "[{")       ("citep" "[{")
        ("citet" "[{")      ("Cite" "[{")
        ("parencite" "[{")  ("Parencite" "[{")
        ("footcite" "[{")   ("footcitetext" "[{")
        ;; Style-specific commands.
        ("textcite" "[{")   ("Textcite" "[{")
        ("smartcite" "[{")  ("Smartcite" "[{")
        ("cite*" "[{")      ("parencite*" "[{")
        ("supercite" "[{")
        ;; Qualified citation lists.
        ("cites" "[{")      ("Cites" "[{")
        ("parencites" "[{") ("Parencites" "[{")
        ("footcites" "[{")  ("footcitetexts" "[{")
        ("smartcites" "[{") ("Smartcites" "[{")
        ("textcites" "[{")  ("Textcites" "[{")
        ("supercites" "[{")
        ;; Style-independent commands.
        ("autocite" "[{")   ("Autocite" "[{")
        ("autocite*" "[{")  ("Autocite*" "[{")
        ("autocites" "[{")  ("Autocites" "[{")
        ;; Text commands.
        ("citeauthor" "[{") ("Citeauthor" "[{")
        ("citetitle" "[{")  ("citetitle*" "[{")
        ("citeyear" "[{")   ("citedate" "[{")
        ("citeurl" "[{")
        ;; Special commands.
        ("fullcite" "[{")
        ;; Cleveref.
        ("cref" "{")          ("Cref" "{")
        ("cpageref" "{")      ("Cpageref" "{")
        ("cpagerefrange" "{") ("Cpagerefrange" "{")
        ("crefrange" "{")     ("Crefrange" "{")
        ("labelcref" "{")))

(setq font-latex-match-textual-keywords
      '(;; BibLaTeX brackets.
        ("parentext" "{") ("brackettext" "{")
        ("hybridblockquote" "[{")
        ;; Auxiliary commands.
        ("textelp" "{")   ("textelp*" "{")
        ("textins" "{")   ("textins*" "{")
        ;; Subcaption.
        ("subcaption" "[{")))

(setq font-latex-match-variable-keywords
      '(;; Amsmath.
        ("numberwithin" "{")
        ;; Enumitem.
        ("setlist" "[{")     ("setlist*" "[{")
        ("newlist" "{")      ("renewlist" "{")
        ("setlistdepth" "{") ("restartlist" "{")
        ("crefname" "{")))
#+end_src

#+begin_src emacs-lisp
(use-package tex-mode
  :defer t
  :straight (:type built-in)
  :config
  (setq LaTeX-section-hook '(LaTeX-section-heading
                             LaTeX-section-title
                             LaTeX-section-toc
                             LaTeX-section-section
                             LaTeX-section-label)
        LaTeX-fill-break-at-separators nil
        LaTeX-item-indent              0))
#+end_src

#+begin_src emacs-lisp
(use-package preview
  :defer t
  :straight (:type built-in)
  :config
  (add-hook 'LaTeX-mode-hook #'LaTeX-preview-setup)
  (setq-default preview-scale 1.4
                preview-scale-function
                (lambda () (* (/ 10.0 (preview-document-pt)) preview-scale)))
  (setq preview-auto-cache-preamble nil)
  (dqv/major-leader-key
    :packages 'auctex
    :keymaps '(latex-mode-map LaTeX-mode-map)
    "p" #'preview-at-point
    "P" #'preview-clearout-at-point))
#+end_src

#+begin_src emacs-lisp
(use-package cdlatex
  :defer t
  :after auctex
  :straight (:build t)
  :hook (LaTeX-mode . cdlatex-mode)
  :hook (org-mode   . org-cdlatex-mode)
  :config
  (setq cdlatex-use-dollar-to-ensure-math nil)
  :general
  (dqv/major-leader-key
    :packages 'cdlatex
    :keymaps 'cdlatex-mode-map
    "$" nil
    "(" nil
    "{" nil
    "[" nil
    "|" nil
    "<" nil
    "^" nil
    "_" nil
    [(control return)] nil))
#+end_src

#+begin_src emacs-lisp
(use-package adaptive-wrap
  :defer t
  :after auctex
  :straight (:build t)
  :hook (LaTeX-mode . adaptative-wrap-prefix-mode)
  :init (setq-default adaptative-wrap-extra-indent 0))
#+end_src

#+begin_src emacs-lisp
(use-package auctex-latexmk
  :after auctex
  :defer t
  :straight (:build t)
  :init
  (setq auctex-latexmk-inherit-TeX-PDF-mode t)
  (add-hook 'LaTeX-mode (lambda () (setq TeX-command-default "LatexMk")))
  :config
  (auctex-latexmk-setup))
#+end_src

#+begin_src emacs-lisp
(use-package company-auctex
  :defer t
  :after (company auctex)
  :straight (:build t)
  :config
  (company-auctex-init))
#+end_src

#+begin_src emacs-lisp
(use-package company-math
  :defer t
  :straight (:build t)
  :after (company auctex)
  :config
  (defun my-latex-mode-setup ()
    (setq-local company-backends
                (append '((company-math-symbols-latex company-latex-commands))
                        company-backends)))
  (add-hook 'TeX-mode-hook #'my-latex-mode-setup))
#+end_src

** Misc
*** ~avy~
~avy~ is a really convenient way of jumping around and performing actions on these selections, but I’ll need some configuration to make it jayden-compatible.
#+begin_src emacs-lisp
(use-package avy
  :defer t
  :straight t
  :config
  (csetq avy-keys           '(?a ?u ?i ?e ?c ?t ?s ?r ?n)
         avy-dispatch-alist '((?x . avy-action-kill-move)
                              (?X . avy-action-kill-stay)
                              (?T . avy-action-teleport)
                              (?m . avy-action-mark)
                              (?C . avy-action-copy)
                              (?y . avy-action-yank)
                              (?Y . avy-action-yank-line)
                              (?I . avy-action-ispell)
                              (?z . avy-action-zap-to-char)))
  (defun my/avy-goto-url ()
    "Jump to url with avy."
    (interactive)
    (avy-jump "https?://"))
  (defun my/avy-open-url ()
    "Open url selected with avy."
    (interactive)
    (my/avy-goto-url)
    (browse-url-at-point))
  :general
  (dqv/evil
    :pakages 'avy
    "gc" #'evil-avy-goto-char-timer
    "gl" #'evil-avy-goto-line)
  (dqv/leader-key
    :packages 'avy
    :infix "A"
    "c"  '(:ignore t :which-key "copy")
    "cl" #'avy-copy-line
    "cr" #'avy-copy-region
    "k"  '(:ignore t :which-key "kill")
    "kl" #'avy-kill-whole-line
    "kL" #'avy-kill-ring-save-whole-line
    "kr" #'avy-kill-region
    "kR" #'avy-kill-ring-save-region
    "m"  '(:ignore t :which-key "move")
    "ml" #'avy-move-line
    "mr" #'avy-move-region
    "mt" #'avy-transpose-lines-in-region
    "n"  #'avy-next
    "p"  #'avy-prev)
  (dqv/major-leader-key
    :packages '(avy org)
    :keymaps 'org-mode-map
    "A" '(:ignore t :which-key "avy")
    "Ar" #'avy-org-refile-as-child
    "Ah" #'avy-org-goto-heading-timer))
#+end_src

*** Keycast
In case I am sharing my screen with people and I want to show which functions are called on my keystrokes since I don’t exactly use standard keybindings.
#+begin_src emacs-lisp
(use-package keycast
  :defer t
  :straight (:build t)
  :config
  (define-minor-mode keycast-mode
    "Show current command and its key binding in the mode line."
    :global t
    (if keycast-mode
        (add-hook 'pre-command-hook 'keycast--update t)
      (remove-hook 'pre-command-hook 'keycast--update)))
  (add-to-list 'global-mode-string '("" mode-line-keycast " ")))
#+end_src

*** Winum
+ allows Emacs to associate windows with a specific number and navigate through these windows by directly refering to their associated number! This allows for faster window configuration than just going to the frame above, then left, left, and up.
#+begin_src emacs-lisp
(use-package winum
  :straight (:build t)
  :init (winum-mode))
#+end_src

* Other
** Github Copilot
#+begin_src emacs-lisp
(use-package copilot
  :straight (:build t :host github :repo "jayden-dang/copilot.el" :files ("dist" "*.el"))
  :ensure t)

;; you can utilize :map :hook and :config to customize copilot
(add-hook 'prog-mode-hook 'copilot-mode)

(with-eval-after-load 'company
  ;; disable inline previews
  (delq 'company-preview-if-just-one-frontend company-frontends))

(define-key copilot-completion-map (kbd "<tab>") 'copilot-accept-completion)
(define-key copilot-completion-map (kbd "TAB") 'copilot-accept-completion)
(define-key copilot-completion-map (kbd "C-s-k") 'copilot-previous-completion)
(define-key copilot-completion-map (kbd "C-s-j") 'copilot-next-completion)

(dqv/leader-key
  "C" '(copilot-mode :which-key "Copilot"))
#+end_src

** Beauty Json
#+begin_src emacs-lisp
(defun beautify-json ()
  (interactive)
  (let ((b (if mark-active (min (point) (mark)) (point-min)))
        (e (if mark-active (max (point) (mark)) (point-max))))
    (shell-command-on-region b e
     "python -mjson.tool" (current-buffer) t)))
#+end_src

** Protobuf
#+begin_src emacs-lisp
(use-package protobuf-mode
  :mode "\\.proto3")
#+end_src

** Writeroom
#+begin_src emacs-lisp
(defun writeroom--calculate-width ()
  "Calculate the width of the writing area."
  (if (floatp writeroom-width)
      (progn
  (message "%s" (window-total-width))
  (truncate (* (window-total-width) writeroom-width)))
    writeroom-width))

(use-package writeroom-mode
  :straight (:build t)
  :config
  (setq writeroom-width 0.95)
  (setq writeroom-mode-line t))
#+end_src

* Programming
*** Tools
**** Treesitter
[[https://emacs-tree-sitter.github.io/][Tree sitter]] is a package for emacs based on [[https://tree-sitter.github.io/tree-sitter/][~tree-sitter~]] which provides a very fast and flexible way of performing code-highlighting in Emacs.
#+begin_src emacs-lisp
(use-package tsc
  :straight (:build t))
(use-package tree-sitter
  :defer t
  :straight (:build t)
  :init (global-tree-sitter-mode))
(use-package tree-sitter-langs
  :defer t
  :after tree-sitter
  :straight (:build t))
#+end_src

**** Flycheck
#+begin_src emacs-lisp
(use-package flycheck
  :straight (:build t)
  :defer t
  :init
  (global-flycheck-mode)
  :config
  (setq flycheck-emacs-lisp-load-path 'inherit)

  ;; Rerunning checks on every newline is a mote excessive.
  (delq 'new-line flycheck-check-syntax-automatically)
  ;; And don’t recheck on idle as often
  (setq flycheck-idle-change-delay 2.0)

  ;; For the above functionality, check syntax in a buffer that you
  ;; switched to on briefly. This allows “refreshing” the syntax check
  ;; state for several buffers quickly after e.g. changing a config
  ;; file.
  (setq flycheck-buffer-switch-check-intermediate-buffers t)

  ;; Display errors a little quicker (default is 0.9s)
  (setq flycheck-display-errors-delay 0.2))
#+end_src

**** Spellcheck
#+begin_src emacs-lisp
(use-package ispell
  :if (executable-find "aspell")
  :defer t
  :straight (:type built-in)
  :config
  (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
  (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
  (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_EXAMPLE" . "#\\+END_EXAMPLE"))
  (setq ispell-program-name "aspell"
        ispell-extra-args   '("--sug-mode=ultra" "--run-together")
        ispell-aspell-dict-dir (ispell-get-aspell-config-value "dict-dir")
        ispell-aspell-data-dir (ispell-get-aspell-config-value "data-dir")
        ispell-personal-dictionary (expand-file-name (concat "ispell/" ispell-dictionary ".pws")
                                                     user-emacs-directory)))
#+end_src

#+begin_src emacs-lisp
(use-package flyspell
  :defer t
  :straight (:type built-in)
  :ghook 'org-mode 'markdown-mode 'TeX-mode
  :init
  (defhydra flyspell-hydra ()
    "
Spell Commands^^           Add To Dictionary^^              Other
--------------^^---------- -----------------^^------------- -----^^---------------------------
[_b_] check whole buffer   [_B_] add word to dict (buffer)  [_t_] toggle spell check
[_r_] check region         [_G_] add word to dict (global)  [_q_] exit
[_d_] change dictionary    [_S_] add word to dict (session) [_Q_] exit and disable spell check
[_n_] next error
[_c_] correct before point
[_s_] correct at point
"
    ("B" nil)
    ("b" flyspell-buffer)
    ("r" flyspell-region)
    ("d" ispell-change-dictionary)
    ("G" nil)
    ("n" flyspell-goto-next-error)
    ("c" flyspell-correct-wrapper)
    ("Q" flyspell-mode :exit t)
    ("q" nil :exit t)
    ("S" nil)
    ("s" flyspell-correct-at-point)
    ("t" nil))
  :config
  (provide 'ispell) ;; force loading ispell
  (setq flyspell-issue-welcome-flag nil
        flyspell-issue-message-flag nil))
#+end_src

#+begin_src emacs-lisp
(use-package flyspell-correct
  :defer t
  :straight (:build t)
  :general ([remap ispell-word] #'flyspell-correct-at-point)
  :config
  (require 'flyspell-correct-ivy nil t))

(use-package flyspell-correct-ivy
  :defer t
  :straight (:build t)
  :after flyspell-correct)
#+end_src

#+begin_src emacs-lisp
(use-package flyspell-lazy
  :defer t
  :straight (:build t)
  :after flyspell
  :config
  (setq flyspell-lazy-idle-seconds 1
        flyspell-lazy-window-idle-seconds 3)
  (flyspell-lazy-mode +1))
#+end_src

**** LSP-Mode
[[https://emacs-lsp.github.io/lsp-mode/][~lsp-mode~]] is a mode for Emacs which implements the [[https://github.com/Microsoft/language-server-protocol/][Language Server Protocol]] and offers Emacs an IDE-like experience. In short, it’s awesome!
#+begin_src emacs-lisp
(use-package lsp-mode
  :defer t
  :straight (:build t)
  :init
  (setq lsp-keymap-prefix "C-c l")
  :hook ((c-mode              . lsp-deferred)
         (c++-mode            . lsp-deferred)
         (html-mode           . lsp-deferred)
         (sh-mode             . lsp-deferred)
         (rustic-mode         . lsp-deferred)
         (go-mode             . lsp-deferred)
         (move-mode           . lsp-deferred)
         (toml-mode           . lsp-deferred)
         (toml-ts-mode        . lsp-deferred)
         (sql-mode            . lsp-deferred)
         (json-mode           . lsp-deferred)
         (zig-mode            . lsp-deferred)
         (typescript-mode     . lsp-deferred)
         (typescript-tsx-mode . lsp-deferred)
         (lsp-mode            . lsp-enable-which-key-integration)
         (lsp-mode            . lsp-ui-mode))
  :commands (lsp lsp-deferred)
  :custom
  (lsp-rust-analyzer-cargo-watch-command "clippy")
  (lsp-eldoc-render-all t)
  (lsp-idle-delay 0.6)
  (lsp-use-plist t)
  (lsp-inlay-hint-enable t)
  (lsp-inlay-hints-mode t)
  (lsp-rust-analyzer-display-lifetime-elision-hints-enable "skip_trivial")
  (lsp-rust-analyzer-display-chaining-hints t)
  (lsp-rust-analyzer-display-lifetime-elision-hints-use-parameter-names nil)
  (lsp-rust-analyzer-display-closure-return-type-hints t)
  (lsp-rust-analyzer-display-parameter-hints nil)
  (lsp-rust-analyzer-display-reborrow-hints nil)
  ;; (lsp-rust-analyzer-store-path "~/.rustup/toolchains/stable-aarch64-apple-darwin/bin/rust-analyzer")
  :config
  (add-hook 'lsp-mode-hook 'lsp-ui-mode)
  (lsp-register-client
   (make-lsp-client :new-connection (lsp-tramp-connection "shellcheck")
                    :major-modes '(sh-mode)
                    :remote? t
                    :server-id 'shellcheck-remote)))

(setq lsp-sqls-workspace-config-path nil)
(setq lsp-enable-indentation nil)
#+end_src

I also want all the visual enhancements LSP can provide.
#+begin_src emacs-lisp
(use-package lsp-ui
  :after lsp
  :defer t
  :straight (:build t)
  :commands lsp-ui-mode
  :custom
  (lsp-ui-peek-always-show t)
  (lsp-ui-sideline-show-hover t)
  (lsp-ui-doc-enable nil)
  :general
  (dqv/major-leader-key
    :keymaps 'lsp-ui-peek-mode-map
    :packages 'lsp-ui
    "h" #'lsp-ui-pook--select-prev-file
    "j" #'lsp-ui-pook--select-next
    "k" #'lsp-ui-pook--select-prev
    "l" #'lsp-ui-pook--select-next-file))
#+end_src

#+begin_src emacs-lisp
(defun dqv/lsp-workspace-remove-missing-projects ()
  (interactive)
  (dolist (dead-project (seq-filter (lambda (x) (not (file-directory-p x))) (lsp-session-folders (lsp-session))))
    (lsp-workspace-folders-remove dead-project)))
#+end_src

And let’s enable some intergration with ~ivy~.
#+begin_src emacs-lisp
(use-package lsp-ivy
  :straight (:build t)
  :defer t
  :after lsp
  :commands lsp-ivy-workspace-symbol)
#+end_src

#+begin_src emacs-lisp
(use-package treesit
  :custom (treesit-font-lock-level 4)
  :straight (:type  built-in))

(use-package treesit-auto
  :straight (:host github :repo "renzmann/treesit-auto")
  :config (setq treesit-auto-install 'prompt)
  :config
  (global-treesit-auto-mode))
#+end_src

#+begin_src emacs-lisp
(use-package lsp-treemacs
  :defer t
  :straight (:build t)
  :requires treemacs
  :config
  (treemacs-resize-icons 15))
#+end_src


#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :defer t
  :straight (:build t)
  :init (exec-path-from-shell-initialize))
#+end_src

#+begin_src emacs-lisp
(use-package consult-lsp
  :defer t
  :after lsp
  :straight (:build t)
  :general
  (dqv/evil
    :keymaps 'lsp-mode-map
    [remap xref-find-apropos] #'consult-lsp-symbols))
#+end_src

+ ~dap-mode~ is an advanced debugging mode that works through lsp.
#+begin_src emacs-lisp
(use-package dap-mode
  :straight (:build t)
  :ensure
  :config
  (dap-ui-mode 1)
  (dap-ui-controls-mode 1)
  (dap-tooltip-mode 1)

  (require 'dap-lldb)
  (require 'dap-gdb-lldb)
  ;; installs .extension/vscode
  (dap-gdb-lldb-setup)
  (dap-register-debug-template "Rust::LLDB Run Configuration"
                               (list :type "lldb-mi"
                                     :request "launch"
                                     :name "LLDB::Run"
                                     :gdbpath "rust-lldb"
                                     :target nil
                                     :cwd nil)))
(setq dap-auto-configure-features '(sessions locals controls breakpoints expressions repl tooltip))
#+end_src

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :ensure
  :init (exec-path-from-shell-initialize))
#+end_src

*** General Programming Languages
**** C/C++
I know, I know, C and C++ no longer are closely related languages, each one of them went their own way and learning C won’t make you a good C++ programmer, neither will the other way around. But, They are still somewhat related, and Emacs thinks so too.
#+begin_src emacs-lisp
(use-package cc-mode
  :straight (:type built-in)
  :defer t
  :init
  (put 'c-c++-backend 'safe-local-variable 'symbolp)
  (add-hook 'c-mode-hook #'tree-sitter-hl-mode)
  (add-hook 'c++-mode-hook #'tree-sitter-hl-mode)
  :config
  (require 'compile)
  :general
  (dqv/underfine
    :keymaps '(c-mode-map c++-mode-map)
    ";" nil)
  (dqv/major-leader-key
   :keymaps '(c-mode-map c++-mode-map)
   "l"  '(:keymap lsp-command-map :which-key "lsp" :package lsp-mode))
  (dqv/evil
   :keymaps '(c-mode-map c++-mode-map)
   "ga" #'projectile-find-other-file
   "gA" #'projectile-find-other-file-other-window))
#+end_src

Something that is also important when working with these languages is
respecting the ~.clang-format~ file that may be provided by a project.
#+begin_src emacs-lisp
(use-package clang-format+
  :straight (:build t)
  :defer t
  :init
  (add-hook 'c-mode-common-hook #'clang-format+-mode))
#+end_src

However, Emacs’ notion of C++ is somewhat outdated, so we need to
update its fontlock.
#+begin_src emacs-lisp
(use-package modern-cpp-font-lock
  :straight (:build t)
  :defer t
  :hook (c++-mode . modern-c++-font-lock-mode))
#+end_src

**** CommonLisp
In Lisp buffers, let’s enable ~parinfer-rust-mode~.
#+begin_src emacs-lisp
(use-package lisp-mode
  :straight (:type built-in)
  :defer t
  :after parinfer-rust-mode
  :hook (lisp-mode . parinfer-rust-mode)
  :config
  (put 'defcommand 'lisp-indent-function 'defun)
  (setq inferior-lisp-program "/usr/bin/sbcl --noinform"))
#+end_src

**** EmacsLisp
This package displays the function’s arglist or variable’s docstring in the echo area at the bottom of the frame. Quite useful indeed.
#+begin_src emacs-lisp
;; (use-package eldoc
;;   :straight t
;;   :defer t
;;   :after company
;;   :preface
;;   (setq eldoc-documentation-strategy 'eldoc-documentation-compose-eagerly)
;;   (add-to-list 'display-buffer-alist
;;             '("^\\*eldoc for" display-buffer-at-bottom
;;               (window-height . 4)))
;;   :hook ((eglot-managed-mode . mp-eglot-eldoc))
;;   :init
;;   (eldoc-add-command 'company-complete-selection
;;                      'company-complete-common
;;                      'company-capf
;;                      'company-abort)
;;   :config
;;   (setq eldoc-echo-area-prefer-doc-buffer t)
;;   (eldoc-add-command-completions "paredit-")
;;   (eldoc-add-command-completions "combobulate-")
;;   (setq eldoc-echo-area-use-multiline-p nil))
#+end_src

#+begin_src emacs-lisp
(add-hook 'emacs-lisp-mode-hook (lambda () (smartparens-mode -1)))
#+end_src

Still on the topic of documentation, I sometimes find it lacks
examples on how to use Elisp functions. ~elisp-demos~ got you covered!
#+begin_src emacs-lisp
(use-package elisp-demos
  :defer t
  :straight (:build t)
  :config
  (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update))
#+end_src

#+begin_src emacs-lisp
(use-package epdh
  :straight (epdh :type git
                  :host github
                  :repo "alphapapa/emacs-package-dev-handbook"
                  :build t)
  :defer t)
#+end_src

Let’s also declare some Elisp-dedicated keybindings, prefixed by a
comma.
#+begin_src emacs-lisp
(dqv/major-leader-key
 :keymaps 'emacs-lisp-mode-map
 "'"   #'ielm
 "c"   '(emacs-lisp-byte-compile :which-key "Byte compile")
 "C"   '(:ignore t :which-key "checkdoc")
 "Cc"  #'checkdoc
 "Cs"  #'checkdoc-start
 "v"   '(:ignore t :which-key "eval")
 "eb"  #'eval-buffer
 "ed"  #'eval-defun
 "ee"  #'eval-last-sexp
 "er"  #'eval-region

 "h"   '(:ignore t :which-key "help")
 "hh"  #'helpful-at-point

 "t"   '(:ignore t :which-key "toggle")
 "tP"  '(:ignore t :which-key "parinfer")
 "tPs" #'parinfer-rust-switch-mode
 "tPd" #'parinfer-rust-mode-disable
 "tPp" #'parinfer-rust-toggle-paren-mode)
#+end_src

Package linting is important when you want to publish your packages to
the world.
#+begin_src emacs-lisp
(use-package package-lint
  :defer t
  :straight (:build t)
  :general
  (dqv/major-leader-key
    :keymaps 'emacs-lisp-mode-map
    :packages 'package-lint
    "l" #'package-lint-current-buffer))
#+end_src

If I need to run CI on a package, [[https://github.com/cask/cask][Cask]] manages its dependencies.
#+begin_src emacs-lisp
(use-package cask-mode
  :defer t
  :straight (:build t))
#+end_src

**** Python
First, we need to set up the main Python mode. With this, we’ll also add Python to the list of LSP languages and to the list of languages org-babel supports.
#+begin_src emacs-lisp
(use-package python
  :defer t
  :straight (:build t)
  :after ob
  :mode (("SConstruct\\'" . python-mode)
         ("SConscript\\'" . python-mode)
         ("[./]flake8\\'" . conf-mode)
         ("/Pipfile\\'"   . conf-mode))
  :init
  (setq python-indent-guess-indent-offset-verbose nil)
  (add-hook 'python-mode-local-vars-hook #'lsp)
  :config
  (setq python-indent-guess-indent-offset-verbose nil)
  (when (and (executable-find "/usr/local/bin/python3")
           (string= python-shell-interpreter "/usr/local/bin/python3"))
    (setq python-shell-interpreter "/usr/local/bin/python3"))
  (setq python-interpreter "/usr/local/bin/python3"))
#+end_src

Now let’s add a package for [[https://docs.pytest.org/en/latest/][pytest]].
#+begin_src emacs-lisp
(use-package pytest
  :defer t
  :straight (:build t)
  :commands (pytest-one
             pytest-pdb-one
             pytest-all
             pytest-pdb-all
             pytest-last-failed
             pytest-pdb-last-failed
             pytest-module
             pytest-pdb-module)
  :config
  (add-to-list 'pytest-project-root-files "setup.cfg")
  :general
  (dqv/major-leader-key
   :keymaps 'python-mode-map
   :infix "t"
   :packages 'pytest
   ""  '(:ignore t :which-key "test")
   "a" #'python-pytest
   "f" #'python-pytest-file-dwim
   "F" #'python-pytest-file
   "t" #'python-pytest-function-dwim
   "T" #'python-pytest-function
   "r" #'python-pytest-repeat
   "p" #'python-pytest-dispatch))
#+end_src

Poetry is a nice tool with which we can manage our Python runtime version as well as our dependencies.
#+begin_src emacs-lisp
(use-package poetry
  :defer t
  :straight (:build t)
  :commands (poetry-venv-toggle
             poetry-tracking-mode)
  :config
  (setq poetry-tracking-strategy 'switch-buffer)
  (add-hook 'python-mode-hook #'poetry-tracking-mode))
#+end_src

This package will bring a new major mode for editing pip requirements.
#+begin_src emacs-lisp
(use-package pip-requirements
  :defer t
  :straight (:build t))
#+end_src

Why use the command line to interact with pip when we can do it with an Emacs frontend?
#+begin_src emacs-lisp
(use-package pippel
  :defer t
  :straight (:build t)
  :general
  (dqv/major-leader-key
   :keymaps 'python-mode-map
   :packages 'pippel
   "P" #'pippel-list-packages))
#+end_src

This is a [[https://github.com/pypa/pipenv][pipenv]] porcelain
#+begin_src emacs-lisp
(use-package pipenv
  :defer t
  :straight (:build t)
  :commands (pipenv-activate
             pipenv-deactivate
             pipenv-shell
             pipenv-open
             pipenv-install
             pipenv-uninstall)
  :hook (python-mode . pipenv-mode)
  :init (setq pipenv-with-projectile nil)
  :general
  (dqv/major-leader-key
   :keymaps 'python-mode-map
   :packages 'pipenv
   :infix "e"
   ""  '(:ignore t :which-key "pipenv")
   "a" #'pipenv-activate
   "d" #'pipenv-deactivate
   "i" #'pipenv-install
   "l" #'pipenv-lock
   "o" #'pipenv-open
   "r" #'pipenv-run
   "s" #'pipenv-shell
   "u" #'pipenv-uninstall))
#+end_src

This integrates ~pyenv~ into ~python-mode~.
#+begin_src emacs-lisp
(use-package pyenv
  :defer t
  :straight (:build t)
  :config
  (add-hook 'python-mode-hook #'pyenv-track-virtualenv)
  (add-to-list 'global-mode-string
               '(pyenv-virtual-env-name (" venv:" pyenv-virtual-env-name " "))
               'append))
#+end_src

Let’s also add a mode for ~pyenv~:
#+begin_src emacs-lisp
(use-package pyenv-mode
  :defer t
  :after python
  :straight (:build t)
  :if (executable-find "pyenv")
  :commands (pyenv-mode-versions)
  :general
  (dqv/major-leader-key
    :packages 'pyenv-mode
    :keymaps 'python-mode-map
    :infix "v"
    "u" #'pyenv-mode-unset
    "s" #'pyenv-mode-set))
#+end_src

This package automatically imports packages we forgot to import.
#+begin_src emacs-lisp
(use-package pyimport
  :defer t
  :straight (:build t)
  :general
  (dqv/major-leader-key
    :packages 'pyimport
    :keymaps 'python-mode-map
    :infix "i"
    ""  '(:ignore t :which-key "imports")
    "i" #'pyimport-insert-missing
    "r" #'pyimport-remove-unused))
#+end_src

On the other hand, this one sorts our imports to make them more readable.
#+begin_src emacs-lisp
(use-package py-isort
  :defer t
  :straight (:build t)
  :general
  (dqv/major-leader-key
   :keymaps 'python-mode-map
   :packages 'py-isort
   :infix "i"
   ""  '(:ignore t :which-key "imports")
   "s" #'py-isort-buffer
   "R" #'py-isort-region))
#+end_src

Access pydoc through counsel.
#+begin_src emacs-lisp
(use-package counsel-pydoc
  :defer t
  :straight (:build t))
#+end_src

This generates Python documentation that is meant to be compatible with Sphinx, a documentation generaton for Python.
#+begin_src emacs-lisp
(use-package sphinx-doc
  :defer t
  :straight (:build t)
  :init
  (add-hook 'python-mode-hook #'sphinx-doc-mode)
  :general
  (dqv/major-leader-key
   :keymaps 'python-mode-map
   :packages 'sphinx-doc
   :infix "S"
   ""  '(:ignore t :which-key "sphinx-doc")
   "e" #'sphinx-doc-mode
   "d" #'sphinx-doc))
#+end_src

Cython is a Python to C compiler. It also introduces the extended Cython programming language which makes writing C for Python easier. This package is a major mode for the Cython programming language.
#+begin_src emacs-lisp
(use-package cython-mode
  :defer t
  :straight (:build t)
  :mode "\\.p\\(yx\\|x[di]\\)\\'"
  :config
  (setq cython-default-compile-format "cython -a %s")
  :general
  (dqv/major-leader-key
   :keymaps 'cython-mode-map
   :packages 'cython-mode
   :infix "c"
   ""  '(:ignore t :which-key "cython")
   "c" #'cython-compile))
#+end_src

Flycheck can also be enabled for Cython:
#+begin_src emacs-lisp
(use-package flycheck-cython
  :defer t
  :straight (:build t)
  :after cython-mode)
#+end_src

Blacken uses the ~black~ formatter backend to format Python buffers.
#+begin_src emacs-lisp
(use-package blacken
  :defer t
  :straight (:build t)
  :init
  (add-hook 'python-mode-hook #'blacken-mode))
#+end_src

Finally, I’m using [[https://github.com/microsoft/pyright][Pyright]] as my LSP backend for Python.
#+begin_src emacs-lisp
(use-package lsp-pyright
  :after lsp-mode
  :defer t
  :straight (:buidl t))
#+end_src

**** Rust
Rust is a general programming language, akin to C++ in some ways, but much more oriented towards safe code, and much better suited for web development. First, let’s install the most important package, ~rustic~.
#+begin_src emacs-lisp
(use-package rustic
  :defer t
  :straight (:build t)
  :mode ("\\.rs\\'" . rustic-mode)
  :hook (rustic-mode-local-vars . rustic-setup-lsp)
  :hook (rustic-mode . lsp-deferred)
  ;; :hook (rustic-mode . eglot-ensure)
  :init
  (with-eval-after-load 'org
    (defalias 'org-babel-execute:rust #'org-babel-execute:rustic)
    (add-to-list 'org-src-lang-modes '("rust" . rustic)))
  ;; (setq rustic-lsp-client 'eglot)
  (add-hook 'rustic-mode-hook #'tree-sitter-hl-mode)
  (add-hook 'rustic-mode-hook
          (lambda ()
            (setq indent-tabs-mode nil)
            (setq tab-width 2)
            (setq rust-indent-offset 2)))
  :general
  (general-define-key
   :keymaps 'rustic-mode-map
   :packages 'lsp
   "M-t" #'lsp-ui-imenu
   "M-?" #'lsp-find-references)
  (dqv/major-leader-key
    :keymaps 'rustic-mode-map
    :packages 'rustic
    "b"  '(:ignore t :which-key "Build")
    "bB" #'rustic-cargo-build
    "bB" #'rustic-cargo-bench
    "bc" #'rustic-cargo-check
    "bC" #'rustic-cargo-clippy
    "bn" #'rustic-cargo-new
    "bo" #'rustic-cargo-outdated
    "d" '(:ignore t :which-key "Debugging")
    "dr" #'dap-debug
    "dh" #'dap-hydra
    "dl" #'dap-debug-last
    "dR" #'dap-debug-restart
    "dq" #'dap-disconnect
    "da" #'dap-breakpoint-add
    "dt" #'dap-breakpoint-toggle
    "dd" #'dap-breakpoint-delete
    "dD" #'dap-breakpoint-delete-all
    "D" #'rustic-cargo-doc
    "f" #'rustic-cargo-fmt
    "a" #'rustic-cargo-add
    "r" #'rustic-cargo-run
    "c" '(:ignore t :which-key "clippy")
    "cf" #'rustic-cargo-clippy-fix
    "cr" #'rustic-cargo-clippy-run
    "cc" #'rustic-cargo-clippy
    "i" #'lsp-execute-code-action ;; auto import
    "l"  '(:ignore t :which-key "Lsp")
    "lr" #'lsp-rename
    "lq" #'lsp-workspace-restart
    "lQ" #'lsp-workspace-shutdown
    "ls" #'lsp-rust-analyzer-status
    "o" '(:ignore t :which-key "Lsp Open")
    "od" #'lsp-rust-analyzer-open-external-docs
    "ot" #'lsp-rust-analyzer-open-cargo-toml
    "t" '(:ignore t :which-key "Testing")
    "tc" #'rustic-cargo-current-test
    "tt" #'rustic-cargo-run-nextest
    "tr" #'lsp-rust-analyzer-related-tests
    "e" #'lsp-rust-analyzer-expand-macro
    "E" #'rustic-cargo-expand-rerun)
  :config
  (setq rustic-indent-method-chain    t
        rustic-babel-format-src-block nil
        rustic-format-trigger         nil)
  (remove-hook 'rustic-mode-hook #'flycheck-mode)
  (remove-hook 'rustic-mode-hook #'flymake-mode-off)
  (remove-hook 'rustic-mode-hook #'rustic-setup-lsp))
;; Use Rustfmt for formatting Rust code in Rustic mode
(setq rustic-format-on-save t)
(setq rustic-format-display-method 'echo)
(setq rustic-format-trigger 'on-save)
(setq rustic-lsp-server 'rust-analyzer)
(setq rustic-lsp-format t)
(setq rustic-lsp-client nil)
(setq rustic-rustfmt-bin (executable-find "rustfmt"))
(setq rustic-rustfmt-config "~/.rustfmt.toml")
#+end_src

#+begin_src emacs-lisp
(defun jd/rustic-mode-hook ()
  (when buffer-file-name
    (setq-local buffer-save-without-query t))
  (add-hook 'before-save-hook 'lsp-format-buffer nil t))
#+end_src

**** Web programming
[[https://emmet.io/][Emmet]] is a powerful templating engine that can generate through simple CSS-like expression some HTML so you don’t have to write everything by hand.
#+begin_src emacs-lisp
(use-package emmet-mode
  :straight (:build t)
  :defer t
  :hook ((css-mode  . emmet-mode)
         (html-mode . emmet-mode)
         (web-mode  . emmet-mode)
         (sass-mode . emmet-mode)
         (scss-mode . emmet-mode)
         (web-mode  . emmet-mode))
  :config
  (general-define-key
   :keymaps 'emmet-mode-keymap
   "M-RET" #'emmet-expand-yas)
  (dqv/major-leader-key
    :keymaps 'web-mode-map
    :packages '(web-mode emmet-mode)
    "e" '(:ignore t :which-key "emmet")
    "ee" #'emmet-expand-line
    "ep" #'emmet-preview
    "eP" #'emmet-preview-mode
    "ew" #'emmet-wrap-with-markup))
#+end_src

Impatient mode serves web buffers live over HTTP so you can see your editions as you type them.
#+begin_src emacs-lisp
(use-package impatient-mode
  :straight (:build t)
  :defer t)
#+end_src

Web mode is a sort of hybrid major mode that allows editing several languages in the same buffer, mainly HTML, CSS, and Javascript.
#+begin_src emacs-lisp
(use-package web-mode
  :defer t
  :straight (:build t)
  :hook html-mode
  :hook (web-mode . prettier-js-mode)
  :hook (web-mode . lsp-deferred)
  :mode (("\\.phtml\\'"      . web-mode)
         ("\\.tpl\\.php\\'"  . web-mode)
         ("\\.twig\\'"       . web-mode)
         ("\\.xml\\'"        . web-mode)
         ("\\.html\\'"       . web-mode)
         ("\\.htm\\'"        . web-mode)
         ("\\.[gj]sp\\'"     . web-mode)
         ("\\.as[cp]x?\\'"   . web-mode)
         ("\\.eex\\'"        . web-mode)
         ("\\.erb\\'"        . web-mode)
         ("\\.mustache\\'"   . web-mode)
         ("\\.handlebars\\'" . web-mode)
         ("\\.hbs\\'"        . web-mode)
         ("\\.eco\\'"        . web-mode)
         ("\\.ejs\\'"        . web-mode)
         ("\\.svelte\\'"     . web-mode)
         ("\\.ctp\\'"        . web-mode)
         ("\\.djhtml\\'"     . web-mode)
         ("\\.vue\\'"        . web-mode))
  :config
  (csetq web-mode-markup-indent-offset 2
         web-mode-code-indent-offset   2
         web-mode-css-indent-offset    2
         web-mode-style-padding        0
         web-mode-script-padding       0)
  :general
  (dqv/major-leader-key
   :keymaps 'web-mode-map
   :packages 'web-mode
   "="  '(:ignore t :which-key "format")
   "E"  '(:ignore t :which-key "errors")
   "El" #'web-mode-dom-errors-show
   "gb" #'web-mode-element-beginning
   "g"  '(:ignore t :which-key "goto")
   "gc" #'web-mode-element-child
   "gp" #'web-mode-element-parent
   "gs" #'web-mode-element-sibling-next
   "h"  '(:ignore t :which-key "dom")
   "hp" #'web-mode-dom-xpath
   "r"  '(:ignore t :which-key "refactor")
   "j"  '(web-mode-tag-match :which-key "Jump Match")
   "rc" #'web-mode-element-clone
   "rd" #'web-mode-element-vanish
   "rk" #'web-mode-element-kill
   "rr" #'web-mode-element-rename
   "rw" #'web-mode-element-wrap
   "z"  #'web-mode-fold-or-unfold)
  (dqv/major-leader-key
    :keymaps 'web-mode-map
    :packages '(lsp-mode web-mode)
    "l" '(:keymap lsp-command-map :which-key "lsp")))
#+end_src

Auto-completion for ~emmet-mode~, ~html-mode~, and ~web-mode~.
#+begin_src emacs-lisp
(use-package company-web
  :defer t
  :straight (:build t)
  :after (emmet-mode web-mode))
#+end_src

***** CSS
Let’s customize a bit the built-in CSS mode.
#+begin_src emacs-lisp
(use-package css-mode
  :defer t
  :straight (:type built-in)
  :hook (css-mode . smartparens-mode)
  :hook (css-mode . lsp-deferred)
  :hook (scss-mode . prettier-js-mode)
  :init
  (put 'css-indent-offset 'safe-local-variable #'integerp)
  :general
  (dqv/major-leader-key
    :keymaps 'css-mode-map
    :packages 'css-mode
    "=" '(:ignore :which-key "format")
    "g" '(:ignore :which-key "goto")))
#+end_src

SCSS is much nicer to use than pure CSS in my opinion, so let’s add a mode for that.
#+begin_src emacs-lisp
(use-package scss-mode
  :straight (:build t)
  :hook (scss-mode . smartparens-mode)
  :hook (scss-mode . lsp-deferred)
  :hook (scss-mode . prettier-js-mode)
  :defer t
  :mode "\\.scss\\'")
#+end_src

And let’s add some autocompletion for CSS.
#+begin_src emacs-lisp
(use-package counsel-css
  :straight (:build t)
  :defer t
  :init
  (cl-loop for (mode-map . mode-hook) in '((css-mode-map  . css-mode-hook)
                                           (scss-mode-map . scss-mode-hook))
           do (add-hook mode-hook #'counsel-css-imenu-setup)
           (dqv/major-leader-key
            :keymaps mode-map
            "gh" #'counsel-css)))
#+end_src

For some reason, although it is built-in, ~less-css-mode~ does not activate when I open ~.less~ files by default. Let’s fix that.
#+begin_src emacs-lisp
(use-package less-css-mode
  :straight  (:type built-in)
  :defer t
  :mode "\\.less\\'"
  :hook (less-css-mode . smartparens-mode)
  :hook (less-css-mode . lsp-deferred)
  :hook (less-css-mode . prettier-js-mode))
#+end_src

***** Javascript
+ ~javascript-mode~ is meh at best, while ~rjsx-mode~ (Real JSX) is much better: it supports both Javascript and ~.jsx~ files for React and Next.JS.
#+begin_src emacs-lisp
(use-package rjsx-mode
  :defer t
  :straight (:build t)
  :after compile
  :mode "\\.[mc]?jsx?\\'"
  :mode "\\.es6\\'"
  :mode "\\.pac\\'"
  :interpreter "node"
  :hook (rjsx-mode . rainbow-delimiters-mode)
  :hook (rjsx-mode . lsp-deferred)
  :hook (rjsx-mode . prettier-js-mode)
  :init
  (add-to-list 'compilation-error-regexp-alist 'node)
  (add-to-list 'compilation-error-regexp-alist-alist
               '(node "^[[:blank:]]*at \\(.*(\\|\\)\\(.+?\\):\\([[:digit:]]+\\):\\([[:digit:]]+\\)"
                      2 3 4))
  :general
  (dqv/major-leader-key
    :keymaps 'rjsx-mode-map
    "rr" #'rjsx-rename-tag-at-point
    "rj" #'rjsx-jump-tag)
  (dqv/evil
    :keymaps 'rjsx-mode-map
    "s-;" #'rjsx-jump-tag
    "s-r" #'rjsx-rename-tag-at-point)
  :config
  (setq js-chain-indent                  t
        js2-basic-offset                 2
        ;; ignore shebangs
        js2-skip-preprocessor-directives t
        ;; Flycheck handles this already
        js2-mode-show-parse-errors       nil
        js2-mode-show-strict-warnings    nil
        ;; conflicting with eslint, Flycheck already handles this
        js2-strict-missing-semi-warning  nil
        js2-highlight-level              3
        js2-idle-timer-delay             0.15))
#+end_src

+ ~js2-refactor~ is an amazing tool for refactoring Javascript code. I mean, [[https://www.youtube.com/watch?v=-7yMWD1wUu4][look at this]]! And the video is only from 2013 and it still receives some commits!
#+begin_src emacs-lisp
(use-package js2-refactor
  :defer t
  :straight (:build t)
  :after (js2-mode rjsx-mode)
  :hook (js2-mode . js2-refactor-mode)
  :hook (rjsx-mode . js2-refactor-mode))
#+end_src

Which Emacser prefers the command line over Emacs itself? I don’t. Let’s interact with NPM through Emacs then.
#+begin_src emacs-lisp
(use-package npm-transient
  :defer t
  :straight (npm-transient :build t
                           :type git
                           :host github
                           :repo "Phundrak/npm-transient"))
  ;; :general
  ;; (dqv/major-leader-key
  ;;   :packages '(npm-transient rjsx-mode web-mode)
  ;;   :keymaps '(rjsx-mode-map web-mode-map)
  ;;   "n" #'npm-transient))
#+end_src

And finally, here is a formatter for Javascript.
#+begin_src emacs-lisp
(use-package prettier-js
  :defer t
  :straight (:build t)
  :after (rjsx-mode web-mode typescript-mode)
  :hook (rjsx-mode . prettier-js-mode)
  :hook (js-mode . prettier-js-mode)
  :hook (typescript-mode . prettier-js-mode)
  :config
  (setq prettier-js-args '("--trailing-comma" "all" "--bracket-spacing" "true")))
#+end_src

***** Typescript
Typescript is a safer alternative to Javascript. Let’s install its major mode then.
#+begin_src emacs-lisp
(use-package typescript-mode
  :defer t
  :straight (:build t)
  :hook (typescript-mode     . rainbow-delimiters-mode)
  :hook (typescript-mode     . lsp-deferred)
  :hook (typescript-mode     . prettier-js-mode)
  :hook (typescript-tsx-mode . lsp-deferred)
  :hook (typescript-tsx-mode . rainbow-delimiters-mode)
  :hook (typescript-tsx-mode . prettier-js-mode)
  ;; :hook (typescript-tsx-mode . eglot-ensure)
  :commands typescript-tsx-mode
  :after flycheck
  :init
  (add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-mode))
  (add-to-list 'auto-mode-alist '("\\.tsx\\'" . typescript-tsx-mode))
  :general
  (dqv/major-leader-key
    :packages 'lsp
    :keymaps '(typescript-mode-map typescript-tsx-mode-map)
    :infix "a"
    ""  '(:keymap lsp-command-map :which-key "lsp")
    "=" '(:ignore t :which-key "format")
    "a" '(:ignore t :which-key "actions"))
  (dqv/major-leader-key
    :packages 'typescript-mode
    :keymaps '(typescript-mode-map typescript-tsx-mode-map)
    "n" '(:keymap npm-mode-command-keymap :which-key "pnpm"))
  :config
  (setq typescript-indent-level 2)
  (with-eval-after-load 'flycheck
    (flycheck-add-mode 'javascript-eslint 'web-mode)
    (flycheck-add-mode 'javascript-eslint 'typescript-mode)
    (flycheck-add-mode 'javascript-eslint 'typescript-tsx-mode)
    (flycheck-add-mode 'typescript-tslint 'typescript-tsx-mode))
  (when (fboundp 'web-mode)
    (define-derived-mode typescript-tsx-mode web-mode "TypeScript-TSX"))
  (autoload 'js2-line-break "js2-mode" nil t))
#+end_src

Tide enabled interactivity with Typescript.
#+begin_src emacs-lisp
(use-package tide
  :defer t
  :straight (:build t)
  :hook (tide-mode . tide-hl-identifier-mode)
  :config
  (setq tide-completion-detailed              t
        tide-always-show-documentation        t
        tide-server-may-response-length       524288
        tide-completion-setup-company-backend nil)

  (advice-add #'tide-setup :after #'eldoc-mode)

  :general
  (dqv/major-leader-key
    :keymaps 'tide-mode-map
    "R"   #'tide-restart-server
    "f"   #'tide-format
    "rrs" #'tide-rename-symbol
    "roi" #'tide-organize-imports))
#+end_src

**** Zig
[[https://ziglang.org/][Zig]] is to C kind of what Rust is to C++: a modern replacement without sacrificing performance. It is much safer than C while providing interop with it. Plus, its [[https://ziglang.org/documentation/master/std/][standard library]] is pretty complete.
First, here is its major mode.

#+begin_src emacs-lisp
(use-package zig-mode
  :defer t
  :straight (:build t)
  :after flycheck
  :config
  ;; This is from DoomEmacs
  (flycheck-define-checker zig
    "A zig syntax checker using the zig-fmt interpreter."
    :command ("zig" "fmt" (eval (buffer-file-name)))
    :error-patterns
    ((error line-start (file-name) ":" line ":" column ": error: " (message) line-end))
    :modes zig-mode)
  (add-to-list 'flycheck-checkers 'zig)
  :general
  (dqv/major-leader-key
    :packages 'zig-mode
    :keymaps 'zig-mode-map
    "c" #'zig-compile
    "f" #'zig-format-buffer
    "r" #'zig-run
    "t" #'zig-test-buffer))

(setq lsp-zig-zls-executable "~/opt/homebrew/bin/zls")
#+end_src

**** Go Lang
#+begin_src emacs-lisp
(use-package go-mode
  :straight (:build t)
  :defer t
  :config
  (add-hook 'before-save-hook #'gofmt-before-save)
  :mode ("\\.go\\'" . go-mode))

(use-package go-snippets
  :defer t)

(defun fix-messed-up-gofmt-path
  (interactive)
  (setq gofmt-command (string-trim (shell-command-to-string "which gofmt"))))

;; (lsp-register-custom-settings
;;  '(("gopls.completeUnimported" t t)
;;    ("gopls.staticcheck" t t)))

(defun lsp-go-install-save-hooks ()
  (add-hook 'before-save-hook #'lsp-format-buffer t t)
  (add-hook 'before-save-hook #'lsp-organize-imports t t))
(add-hook 'go-mode-hook #'lsp-go-install-save-hooks)

(require 'project)

(defun project-find-go-module (dir)
  (when-let ((root (locate-dominating-file dir "go.mod")))
    (cons 'go-module root)))

(cl-defmethod project-root ((project (head go-module)))
  (cdr project))

(add-hook 'project-find-functions #'project-find-go-module)

;; (add-hook 'go-mode-hook 'eglot-ensure)

(defun eglot-format-buffer-on-save ()
  (add-hook 'before-save-hook #'eglot-format-buffer -10 t))
(add-hook 'go-mode-hook #'eglot-format-buffer-on-save)
#+end_src

*** DSLs
DSLs, or /Domain Specific Languages/, are languages dedicated to some very tasks, such as configuration languages or non-general programming such as SQL.
**** Makefiles
#+begin_src emacs-lisp
(defun my/local-tab-indent ()
  (setq-local indent-tabs-mode 1))

(add-hook 'makefile-mode-hook #'my/local-tab-indent)
#+end_src

**** Dotenv
It is not rare to encounter a dotenv file, that is, a file with either the ~.env~ extension or simply called ~.env~. They contain environment variables for projects which might rely on values you do not want to upload to a public git repository and such. While their syntax is similar to shell files, they’re not exactly shell files either since there’s rarely any script inside running. So, let’s install a simple package which will dumb down a lot ~sh-mode~ for these dotenv files.
#+begin_src emacs-lisp
(use-package dotenv-mode
  :defer t
  :straight (:build t))
#+end_src

**** Solidity
#+begin_src emacs-lisp
(use-package solidity-mode
  :defer t
  :straight (:build t)
  :config
  (csetq solidity-comment-style 'slash))
#+end_src

**** Json
#+begin_src emacs-lisp
(use-package json-mode
  :straight (:build t)
  :mode "\\.json$"
  :config
  (add-to-list 'flycheck-disabled-checkers 'json-python-json)
  :general
  (dqv/major-leader-key
    :packages 'json-mode
    :keymaps 'json-mode-map
    "f" #'json-pretty-print-buffer))
#+end_src

**** Toml
#+begin_src emacs-lisp
(use-package toml-mode
  :straight (:build t)
  :defer t
  :mode "/\\(Cargo.lock\\|\\.cargo/config\\)\\'")
#+end_src

**** Yaml
#+begin_src emacs-lisp
(use-package yaml-mode
  :defer t
  :straight (:build t)
  :mode "\\.yml\\'"
  :mode "\\.yaml\\'")
#+end_src

**** Move-languages
#+begin_src emacs-lisp
(use-package move-mode
  :straight (:build t :host github :repo "amnn/move-mode" :branch "main"))

(add-hook 'move-mode-hook #'eglot-ensure)
;;           (add-to-list 'eglot-server-programs '(move-mode "sui-move-analyzer"))

(defun my/move-lsp-project-root (dir)
  (and-let* (((boundp 'eglot-lsp-context))
             (eglot-lsp-context)
             (override (locate-dominating-file dir "Move.toml")))
    (cons 'Move.toml override)))

(add-hook 'project-find-functions #'my/move-lsp-project-root)
(cl-defmethod project-root ((project (head Move.toml)))
  (cdr project))

(with-eval-after-load 'lsp-mode
  (add-to-list 'lsp-language-id-configuration '(move-mode . "move"))
  (lsp-register-client
   (make-lsp-client
    :new-connection (lsp-stdio-connection "sui-move-analyzer")
    :activation-fn (lsp-activate-on "move")
    :priority -1
    :server-id 'move-analyzer)))

(use-package eglot
 :config
 (add-to-list 'eglot-server-programs '(move-mode "sui-move-analyzer")))
#+end_src

* Keybindings
Undefining some stuff to make keybind prefixes work correctly.
#+begin_src emacs-lisp
  (dqv/evil
    ;;:packages '(counsel)
    "s" '(window-configuration-to-register :wk "Register Window")
    "f" '(jump-to-register :wk "Jump Register")
    "K"   #'lsp-ui-doc-glance
    "U"   #'evil-redo
    "C-a" #'my-smarter-move-beginning-of-line
    "C-e" #'end-of-line
    "*"   #'dired-create-empty-file
    "C-y" #'yank
    "C-M-s-p"    #'scroll-half-page-up
    "C-M-s-n"    #'scroll-half-page-down
    "M-y" #'counsel-yank-pop)
#+end_src

#+begin_src emacs-lisp
(dqv/leader-key
  "SPC" '(counsel-M-x :which-key "M-x")
  "."  '(dirvish-dwim :which-key "Dirvish")
  ;; "."  '(dired-jump :which-key "Dirvish")
  "'"   '(shell-pop :which-key "shell-pop")
  ","  '(magit-status :which-key "Magit Status")
  "j" '(bufler-switch-buffer :which-key "Switch Buffer")
  "k" '(dqv/switch-to-previous-buffer :which-key "Switch to previous buffer")
  "oa" '(org-agenda :color blue :which-key "Agenda")
  "ol" '(my/avy-open-url :color blue :which-key "Open Url")
  "of" '(browse-file-directory :which-key "Open File in Directory")
  "1" '(treemacs :which-key "Open Treemacs")

  "a" '(:ignore t :which-key "Application")
  "ac" '(calendar :which-key "Calendar")

  "s" '(:ignore t :which-key "Set Timer")
  "st" '(org-timer :which-key "Timer")
  "si" '(org-timer-item :which-key "Timer")
  "ss" '(org-timer-set-timer :which-key "Set Timer")
  "sp" '(org-timer-pause-or-continue :which-key "Pause / Continue")
  "s1" '(org-timer-start :which-key "Start")
  "s2" '(org-timer-stop :which-key "Stop")
  "wr" '(writeroom-mode :which-key "Write Room")

  "d" '(:ignore t :which-key "Dirvish")
  "os" '(dirvish-side :which-key "Side")
  "il" '(org-insert-last-stored-link :which-key "Insert Stored Link")
  "is" '(org-store-link :which-key "Store Link"))

(dqv/leader-key
  :packages '(bufler)
  "b" '(:ignore t :which-key "Buffers")
  "J" '(bufler :which-key "Buflers")
  "bb" '(bufler-switch-buffer :which-key "Switch Buffer")
  "bB" '(bury-buffer :which-key "Bury Buffer")
  "bc" '(clone-indirect-buffer :which-key "Clone Indirect")
  "bC" '(clone-indirect-buffer-other-window :which-key "Clone Indirect Other Window")
  "bl" '(bufler :which-key "Bufler")
  "br" '(rename-buffer :which-key "Rename buffer")
  "bk" '(kill-this-buffer :which-key "Kill This Buffer")
  "bD" '(kill-buffer :which-key "Kill Buffer")
  "bh" '(dashboard-refresh-buffer :which-key "Dashboard Refresh Buffer")
  "bm" '(switch-to-message-buffer :which-key "Switch to message buffer")
  "bn" '(next-buffer :which-key "Next Buffer")
  "bp" '(previous-buffer :which-key "Next Buffer")
  "bs" '(switch-to-scratch-buffer :which-key "Scratch Buffer"))

(dqv/leader-key
  :packages '(treemacs)
  "t" '(:ignore t :wk "Treemacs")
  "tc" '(:ignore t :wk "Create")
  "tcd" '(treemacs-create-dir :which-key "Create Dir")
  "tcf" '(treemacs-create-file :which-key "Create File")
  "tci" '(treemacs-create-icon :which-key "Create Icon")
  "tct" '(treemacs-create-theme :which-key "Create Theme")
  "td" '(treemacs-delete-file :which-key "delete")
  "tw" '(:ignore t :wk "Workspace")
  "tws" '(treemacs-switch-workspace :which-key "Switch Workspace")
  "twc" '(treemacs-create-workspace :which-key "Create Workspace")
  "twr" '(treemacs-remove-workspace :which-key "Remove Workspace")
  "tf" '(:ignore t :wk "Files")
  "tff" '(treemacs-find-file :which-key "Find File")
  "tft" '(treemacs-find-tag :which-key "Find Tag")
  "tl" '(:ignore t :wk "LSP")
  "tls" '(treemacs-expand-lsp-symbol :which-key "Lsp Symbol")
  "tt" '(typescript-tsx-mode :which-key "TSX Mode")

  "tld" '(treemacs-expand-lsp-treemacs-deps :which-key "Lsp treemacs deps")
  "tlD" '(treemacs-collapse-lsp-treemacs-deps :which-key "Collapse lsp Deps")
  "tlS" '(treemacs-collapse-lsp-symbol :which-key "Collapse Lsp Symbol")
  "tp" '(:ignore t :wk "Projcets")
  "tpa" '(treemacs-add-project :which-key "Add project")
  "tpf" '(treemacs-project-follow-mode :which-key "Follow mode")
  "tpn" '(treemacs-project-of-node :which-key "Of Node")
  "tpp" '(treemacs-project-at-point :which-key "At Point")
  "tpr" '(treemacs-remove-project-from-workspace :which-key "Remove project")
  "tpt" '(treemacs-move-project-down :which-key "Project Down")
  "tps" '(treemacs-move-project-up :which-key "Project Up")
  "tr" '(:ignore t :wk "Rename")
  "trf" '(treemacs-rename-file :which-key "Rename File")
  "trp" '(treemacs-rename-project :which-key "Rename project")
  "trr" '(treemacs-rename :which-key "Rename")
  "trw" '(treemacs-rename-workspace :which-key "Rename Workspace")
  "tT" '(:ignore t :wk "Toggle")
  "tTd" '(treemacs-toggle-show-dotfiles :which-key "Toggle show Dotfiles")
  "tTn" '(treemacs-toggle-node :which-key "Toggle Node")
  "tv" '(:ignore t :wk "Visit Node")
  "tva" '(treemacs-visit-node-ace :which-key "Visit Ace")
  "tvc" '(treemacs-visit-node-close-treemacs :which-key "Visit Node Close")
  "tvn" '(treemacs-visit-node-default :which-key "Visit Node")
  "ty" '(:ignore t :wk "Yank")
  "tya" '(treemacs-copy-absolute-path-at-point :which-key "Absolute")
  "typ" '(treemacs-copy-project-path-at-point :which-key "Project")
  "tyr" '(treemacs-copy-relative-path-at-point :which-key "Relative")
  "tyr" '(treemacs-copy-file :which-key "file"))

(dqv/leader-key
  "c"   '(:ignore t :wk "code")
  "cl"  #'evilnc-comment-or-uncomment-lines

  "e"  '(:ignore t :which-key "errors")
  "e." '(hydra-flycheck/body :wk "hydra")
  "el" '(counsel-flycheck :wk "Flycheck")
  "eF" #'flyspell-hydra/body

  "f"   '(:ignore t :wk "Files")
  "ff" '(counsel-find-file :wk "Find Files")
  "fD" '(dqv/delete-this-file :wk "Delete Files")
  "fr" '(counsel-recentf :wk "Recentf Files"))

(dqv/leader-key
  "h"   '(:ignore t :wk "Help")
  "hi" '(info :wk "Info")
  "hI" '(info-display-manual :wk "Info Display")
  "hd"   '(:ignore t :wk "Describe")
  "hdk" '(helpful-key :wk "Key")
  "hdm" '(helpful-macro :wk "Macro")
  "hds" '(helpful-symbol :wk "Symbol")
  "hdv" '(helpful-variable :wk "Variable")

  "i"   '(:ignore t :wk "insert")
  "iu"  #'counsel-unicode-char

  "t"   '(:ignore t :wk "Insert")
  "tT"  #'counsel-load-theme
  "tml"  #'modus-themes-load-operandi
  "tmd"  #'modus-themes-load-vivendi
  "td"  '(:ignore t :wk "Debug")
  "tde"  #'toggle-debug-on-error
  "tdq"  #'toggle-debug-on-quit
  "ti"   '(:ignore t :wk "Input")
  "tit"  #'toggle-input-method
  "tis"  #'set-input-method

  "T"   '(:ignore t :wk "Input")
  "Te"  #'string-edit-at-point
  "Tu"  #'downcase-region
  "TU"  #'upcase-region
  "Tz"  #'hydra-zoom/body

  "w"   '(:ignore t :wk "Windows")
  "wh" '(evil-window-left :wk "Left")
  "wj" '(evil-window-down :wk "Down")
  "wk" '(evil-window-up :wk "Up")
  "wl" '(evil-window-right :wk "Right")
  "ws" '(split-window-below-and-focus :wk "Split")
  "wv" '(split-window-right-and-focus :wk "Verticle Split")
  "wi" '(windows-adjust-size/body :wk "Window Size")
  "w1" #'winum-select-window-1
  "w2" #'winum-select-window-2
  "w3" #'winum-select-window-3
  "w4" #'winum-select-window-4
  "wc" '(kill-buffer-and-delete-window :wk "Kill & Delete")
  "wO" '(dqv/kill-other-buffers :wk "Kill other window")
  "wd" '(delete-window :wk "Delete window")
  "wo" '(delete-other-windows :wk "delete others window")

  "ag"   '(:ignore t :wk "Gcal")
  "agp"  #'org-gcal-post-at-point
  "agR"  #'org-gcal-reload-client-id-secret
  "ags"  #'org-gcal-sync
  "agS"  #'org-gcal-sync-buffer
  "agf"  #'org-gcal-fetch
  "agF"  #'org-gcal-fetch-buffer
  "agd"  #'org-gcal-delete-at-point
  "agr"  #'org-gcal-request-token
  "agt"  #'org-gcal-toggle-debug

  "n"   '(:ignore t :wk "Gcal")
  "nn"  #'org-roam-node-find
  "naa"  #'org-roam-alias-add
  "nar"  #'org-roam-alias-remove
  "ni"  #'org-roam-node-insert
  "nl"  #'org-roam-buffer-toggle
  "nct"  #'org-roam-dailies-capture-today
  "ncT"  #'org-roam-dailies-capture-tomorrow
  "nfd"  #'org-roam-dailies-find-date
  "nft"  #'org-roam-dailies-find-today
  "nfy"  #'org-roam-dailies-find-yesterday
  "nfT"  #'org-roam-dailies-find-tomorrow
  "ng"  #'org-roam-graph
  "nbs"  #'bookmark-set
  "nbj"  #'bookmark-jump
  "nbi"  #'bookmark-insert
  "nbl"  #'bookmark-bmenu-list

  "l"   '(:ignore t :wk "Lsp")
  "ll"  #'lsp
  "lm"  #'lsp-ui-imenu
  "lR"  #'lsp-workspace-restart
  "ls"  #'lsp-treemacs-symbols
  "le"  #'lsp-treemacs-errors-list
  "ld"  #'xref-find-definitions-other-window
  "lD"  #'xref-find-definitions
  "lr"  #'lsp-rename

  "all" #'leetcode
  "ald" #'leetcode-daily
  "alo" #'leetcode-show-problem-in-browser
  "alO" #'leetcode-show-problem-by-slub
  "alS" #'leetcode-submit
  "als" #'leetcode-show-problem

  "p" '(:ignore t :wk "Projectile")
  "p!" #'projectile-run-shell-command-in-root
  "p&" #'projectile-run-async-shell-command-in-root
  "pb" #'counsel-projectile-switch-to-buffer
  "pc" #'counsel-projectile
  "pr" #'projectile-remove-known-project
  "pd" #'counsel-projectile-find-dir
  "pe" #'projectile-edit-dir-locals
  "pf" #'counsel-projectile-find-file
  "pg" #'projectile-find-tag
  "pk" #'project-kill-buffers
  "pp" #'counsel-projectile-switch-project
  "pt" #'ivy-magit-todos
  "pv" #'projectile-vc

  "u"   #'universal-argument
  "U"   #'undo-tree-visualize

  "fd"  '((lambda ()
            (interactive)
            (find-file "~/Dropbox/Roam/"))
          :which-key "Roam")

  "fo"  '((lambda ()
            (interactive)
            (find-file "~/Dropbox/Roam/README.org"))
          :which-key "init.el")


  "fc"  '((lambda ()
            (interactive)
            (find-file "~/.emacs.d/jayden.org"))
          :which-key "jayden.org")

  "fi"  '((lambda ()
            (interactive)
            (find-file (concat user-emacs-directory "init.el")))
          :which-key "init.el")

  "fR"  '((lambda ()
            (interactive)
            (counsel-find-file ""
                               (concat user-emacs-directory
                                       (file-name-as-directory "straight")
                                       (file-name-as-directory "repos"))))
          :which-key "straight package")

  "owgp"  '((lambda ()
             (interactive)
             (browse-url "https://github.com/jayden_dangvu"))
            :wk "My Github")

  "owgw"  '((lambda ()
             (interactive)
             (browse-url "https://github.com/orgs/TOCE-Team/repositories"))
            :wk "Work Github")

  "owe"  '((lambda ()
             (interactive)
             (browse-url "https://remix.ethereum.org/"))
           :wk "Remix IDE")

  "owr"  '((lambda ()
             (interactive)
             (browse-url "https://reddit.com/"))
           :wk "Reddit")

  "owc"  '((lambda ()
             (interactive)
             (browse-url "https://calendar.google.com/calendar/u/0/r?pli=1"))
           :wk "My Calender")

  "owwc"  '((lambda ()
              (interactive)
              (browse-url "https://chat.openai.com"))
            :wk "Chat GPT"))

#+end_src

*** Docker
#+begin_src emacs-lisp
(dqv/leader-key
  "dd" '(docker :which-key "Docker")
  "dI" '(docker-images :which-key "Docker Images")
  "dV" '(docker-volumes :which-key "Docker Volumes")
  "dC" '(docker-containers :which-key "Docker Containers")
  "dN" '(docker-networks :which-key "Docker Networks")
)
#+end_src

* More Configuration
** Yabai
#+begin_src emacs-lisp :mkdirp yes :tangle ~/.config/yabai/yabairc :export code :results silent :lexical t
# bsp, stack or float
yabai -m config layout bsp

yabai -m config window_placement second_child

# padding
yabai -m config top_padding 12
yabai -m config bottom_padding 12
yabai -m config left_padding 12
yabai -m config right_padding 12
yabai -m config window_gap 12

# Mouse setting

yabai -m config mouse_follows_focus on

yabai -m config mouse_modifier alt
# left click + drag
yabai -m config mouse_action1 move
# right click + drag
yabai -m config mouse_action2 resize

ybai -m mouse_drop_action swap

# Deisable Specific Apps
yabai -m rule --add app="^System Settings$" manage=off
yabai -m rule --add app="^Calculator$" manage=off
yabai -m rule --add app="^Karabiner-Elements$" manage=off
yabai -m rule --add app="^Finder$" manage=off
yabai -m rule --add app="^Telegram$" manage=off
yabai -m rule --add app="^iTerm2$" manage=off
#+end_src

** skdh
#+begin_src emacs-lisp :mkdirp yes :tangle ~/.config/skhd/skhdrc :export code :results silent :lexical t
# Changing Window Focus

# Change Window FOcus Within Space
alt - j : yabai -m window --focus south
alt - k : yabai -m window --focus north
alt - h : yabai -m window --focus west
alt - l : yabai -m window --focus east

# Change focus between external displays (left and right)
alt - n : yabai -m display --focus west
alt - p : yabai -m display --focus east

# Modifying the layout
# Rotate layout clockwise
shift + alt - r : yabai -m space --rotate 270

# Flip along y-axis
shift + alt - y : yabai -m space --mirror y-axis

# Flip along x-axis
shift + alt - x : yabai -m space --mirror x-axis

# Toggle window float
shift + alt - t : yabai -m window --toggle float --grid 4:4:1:1:2:2

# Maximize a window
shift + alt - m : yabai -m window --toggle zoom-fullscreen

# balance out tree of windows (resize to occupy same area)
shift + alt - e : yabai -m space --balance

# swap windows
shift + alt - j : yabai -m window --swap south
shift + alt - k : yabai -m window --swap north
shift + alt - h : yabai -m window --swap west
shift + alt - l : yabai -m window --swap east

# Move window and split
ctrl + alt - j : yabai -m window --warp south
ctrl + alt - k : yabai -m window --warp north
ctrl + alt - h : yabai -m window --warp west
ctrl + alt - l : yabai -m window --warp east

# move window to display left and right
shift + alt - s : yabai -m window --display west; yabai -m display --focus west;
shift + alt - g : yabai -m window --display east; yabai -m display --focus east;

# Move window to prev and next space
shift + alt - p : yabai -m window --space prev;
shift + alt - n : yabai -m window --space next;

# Move window to space #
shift + alt - 1 : yabai -m window --space 1;
shift + alt - 2 : yabai -m window --space 2;
shift + alt - 3 : yabai -m window --space 3;
shift + alt - 4 : yabai -m window --space 4;
shift + alt - 5 : yabai -m window --space 5;
shift + alt - 6 : yabai -m window --space 6;
shift + alt - 7 : yabai -m window --space 7;
shift + alt - 8 : yabai -m window --space 8;
shift + alt - 9 : yabai -m window --space 9;

# Start/Stop yabai
ctrl + alt - q : yabai --stop-service
ctrl + alt - s : yabai --start-service
#+end_src

** Zsh
#+begin_src emacs-lisp :mkdirp yes :tangle no :export code :results silent :lexical t
# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
# Initialization code that may require console input (password prompts, [y/n]
# confirmations, etc.) must go above this block; everything else may go below.
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# PATH
export PATH=$HOME/bin:/usr/local/bin:$PATH
export PATH=$HOME/opt/homebrew/opt/llvm/bin:$PATH

export ZSH="$HOME/.oh-my-zsh"
export LANG=en_US.UTF-8

ZSH_THEME="powerlevel10k/powerlevel10k"

source $ZSH/oh-my-zsh.sh

export EDITOR='nvim'

plugins=(zsh-syntax-highlighting rust)
source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh
ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE="fg=#ff4f00, bold, underline"


# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

# Alias exa
alias ls='exa --icons -F -H --group-directories-first --git -1'
alias ll='ls -alF'
alias cl='clear'
alias pn='pnpm'
alias tr='terraform'
alias dk='docker'
alias dc='docker container'
alias di='docker image'
alias dn='docker network'
alias dv='docker volume'

# Alias Rust
alias cm='cargo make'
alias gen='cargo generate'

# Alias
alias vim='nvim'

# Rust
source "$HOME/.cargo/env"

# Node Version Management
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

export PATH="$HOME/bin:$HOME/.cargo/bin:$PATH"
export DOTNET_ROOT="$HOME/.dotnet"
export PATH="$HOME/.dotnet/tools:$PATH"
export Z3_EXE="$HOME/bin/z3"
export CVC5_EXE="$HOME/bin/cvc5"
export BOOGIE_EXE="$HOME/.dotnet/tools/boogie"

# Postgres
export PATH="/opt/homebrew/opt/postgresql@15/bin:$PATH"

# >>>> Vagrant command completion (start)
fpath=(/opt/vagrant/embedded/gems/gems/vagrant-2.4.0/contrib/zsh $fpath)
compinit
# <<<<  Vagrant command completion (end)
#+end_src

** Grammarly
#+begin_src emacs-lisp
(use-package lsp-grammarly
  :straight (:build t))
  ;; :ensure nil
  ;; :hook (text-mode . (lambda ()
  ;;                      (require 'lsp-grammarly)
  ;;                      (lsp-deferred))))  ; or lsp-deferred
#+end_src

** MarkdownX
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.mdx\\'" . markdown-mode))
#+end_src
